<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>AAU Robot Dashboard</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Overall Grid: 2 rows, 2 columns - Responsive */
    #dashboard {
      display: grid;
      grid-template-rows: 50% 50%;
      grid-template-columns: 50% 50%;
      width: 100vw;
      height: 100vh;
      min-width: 320px;  /* Mobile minimum */
      min-height: 480px; /* Mobile minimum */
      box-sizing: border-box;
      overflow: hidden;
    }
    
    /* Responsive breakpoints */
    @media (max-width: 1200px) {
      #dashboard {
        grid-template-rows: 1fr 1fr;
        grid-template-columns: 1fr 1fr;
      }
    }
    
    @media (max-width: 768px) {
      #dashboard {
        grid-template-rows: 1fr 1fr 1fr 1fr;
        grid-template-columns: 1fr;
      }
      
      /* Stack panels vertically on mobile */
      .panel:nth-child(1) { grid-row: 1; grid-column: 1; }
      .panel:nth-child(2) { grid-row: 2; grid-column: 1; }
      .panel:nth-child(3) { grid-row: 3; grid-column: 1; }
      .panel:nth-child(4) { grid-row: 4; grid-column: 1; }
      
      /* Adjust camera panel layout for mobile */
      .panel[style*="flex-direction:row"] {
        flex-direction: column !important;
      }
      
      /* Adjust robot control layout for mobile */
      .panel[style*="grid-row:1"][style*="grid-column:2"] > div[style*="height:50%"] {
        height: auto !important;
      }
    }
    
    /* Ultra small screens */
    @media (max-width: 480px) {
      body {
        font-size: 12px;
      }
      
      .panel-title {
        font-size: 0.8rem !important;
      }
      
      /* Hide some less critical elements on very small screens */
      .instructions-area {
        display: none;
      }
    }
    .panel {
      border: 1px solid #444;
      background: #2a2a2a;
      position: relative;
      display: flex;
      flex-direction: column;
      padding: 8px;
      box-sizing: border-box;
    }
    
    /* Responsive panel adjustments */
    @media (max-width: 768px) {
      .panel {
        padding: 4px;
        min-height: 200px;
      }
    }
    .panel-title {
      position: absolute;
      top: 8px;
      left: 8px;
      font-weight: bold;
      color: #fff;
      z-index: 2;
      font-size: 1rem;
    }
    
    /* Responsive panel title */
    @media (max-width: 768px) {
      .panel-title {
        font-size: 0.9rem;
        top: 4px;
        left: 4px;
      }
    }
    /* For video/image in each window */
    .media-container {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      position: relative;
    }
    /* Ensure video/image fills the container width and scales */
    .media-content {
      width: 100%; /* Fill the full width of the container */
      height: 100%; /* Fill the full height of the container */
      object-fit: contain; /* Maintain aspect ratio while fitting within container */
      display: block;
    }
    
    /* Responsive media content */
    @media (max-width: 768px) {
      .media-content {
        object-fit: cover; /* Better fit for small screens */
      }
    }
    #llmConsole {
      font-size: 1.2em;          /* Reduced from 2em to 1.2em */
      line-height: 1.4;
      white-space: pre-wrap;   /* keep spaces & wrap long lines */
      word-break: break-word;
      color: #4af;             /* Blue for LLM Reasoning */
    }
    
    /* Responsive LLM Console */
    @media (max-width: 1200px) {
      #llmConsole {
        font-size: 1.1em;
      }
    }
    
    @media (max-width: 768px) {
      #llmConsole {
        font-size: 1em;
      }
    }
    
    @media (max-width: 480px) {
      #llmConsole {
        font-size: 0.9em;
      }
    }
    .console-area {
      background: #111;
      border: 1px solid #4af;
      font-family: monospace;
      padding: 4px;
      overflow-y: auto;
      flex: 1;
    }
    .neon-btn {
      background-color: #222;
      color: #4af;
      border: 1px solid #4af;
      transition: all 0.2s ease-in-out;
    }
    .neon-btn:hover {
      background-color: #4af;
      color: #111;
      box-shadow: 0 0 8px #4af;
    }
    select {
      background-color: #2a2a2a;
      color: #4af;
      border: 1px solid #4af;
      padding: 4px;
    }
    /* Chat messages font size - reduced for better readability */
    #chatMessages {
      font-size: 1.1em;        /* Reduced from 1.6em to 1.1em */
      line-height: 1.4;
      overflow-y: auto;
      background: #111;
      border: 1px solid #666;
      padding: 8px;
      margin-top: 8px;
    }
    
    /* Responsive Chat Messages */
    @media (max-width: 1200px) {
      #chatMessages {
        font-size: 1em;
        padding: 6px;
      }
    }
    
    @media (max-width: 768px) {
      #chatMessages {
        font-size: 0.95em;
        padding: 4px;
        margin-top: 4px;
      }
    }
    
    @media (max-width: 480px) {
      #chatMessages {
        font-size: 0.85em;
      }
    }
    /* Default message styling - all text white */
    #chatMessages div {
      color: #ffffff; /* White for all message content */
      margin-bottom: 0.5em;
    }
    /* Max's name only in blue */
    #chatMessages div[data-sender="Max"] strong {
      color: #4af; /* Blue for Max's name only */
    }
    /* User's name only in green */
    #chatMessages div[data-sender="You"] strong {
      color: #90ee90; /* Green for User's name only */
    }
    /* Instructions area styling - smaller font size */
    .instructions-area {
      height: 30%; /* Increased from 20% to 30% */
      margin-top: 30px; 
      background: #0a0a0a; 
      border: 1px solid #4af; 
      padding: 12px; /* Increased from 8px */
      border-radius: 4px; 
      overflow-y: auto;
      font-size: 0.9em; /* Reduced from 1.35em to 0.9em for smaller text */
    }
    .instructions-title {
      color: #4af; 
      font-weight: bold; 
      margin-bottom: 6px; /* Increased from 4px */
      font-size: 1.1em; /* Slightly larger title */
    }
    .instructions-content {
      line-height: 1.4; /* Increased from 1.3 */
      color: #ccc;
    }
    /* Chat input area styling - larger message box */
    #chatInput {
      font-size: 1.5em; /* Larger input text */
      padding: 8px; /* More padding */
    }
    .chat-send-btn {
      font-size: 1.2em; /* Larger button text */
      padding: 8px 16px; /* More padding */
    }
    
    /* Responsive Chat Input */
    @media (max-width: 1200px) {
      #chatInput {
        font-size: 1.3em;
        padding: 6px;
      }
      .chat-send-btn {
        font-size: 1.1em;
        padding: 6px 12px;
      }
    }
    
    @media (max-width: 768px) {
      #chatInput {
        font-size: 1.1em;
        padding: 4px;
      }
      .chat-send-btn {
        font-size: 1em;
        padding: 4px 8px;
      }
    }
    
    @media (max-width: 480px) {
      #chatInput {
        font-size: 1em;
        padding: 3px;
      }
      .chat-send-btn {
        font-size: 0.9em;
        padding: 3px 6px;
      }
    }

    /* Robot Control Button Styles */
    .robot-btn {
      padding: 6px 12px;
      border: 2px solid;
      border-radius: 5px;
      font-size: 0.9em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      min-width: 100px;
    }
    
    /* Responsive Robot Buttons */
    @media (max-width: 1200px) {
      .robot-btn {
        font-size: 0.8em;
        padding: 5px 10px;
        min-width: 80px;
      }
    }
    
    @media (max-width: 768px) {
      .robot-btn {
        font-size: 0.7em;
        padding: 4px 8px;
        min-width: 60px;
      }
    }
    
    @media (max-width: 480px) {
      .robot-btn {
        font-size: 0.6em;
        padding: 3px 6px;
        min-width: 50px;
      }
    }

    .robot-btn-red {
      background-color: #dc3545;
      border-color: #dc3545;
      color: white;
    }

    .robot-btn-yellow {
      background-color: #ffc107;
      border-color: #ffc107;
      color: #212529;
    }

    .robot-btn-green {
      background-color: #28a745;
      border-color: #28a745;
      color: white;
    }

    .robot-btn-gray {
      background-color: #6c757d;
      border-color: #6c757d;
      color: white;
    }

    .robot-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .movement-btn {
      padding: 4px 8px;
      border: 2px solid #4af;
      border-radius: 3px;
      background-color: #222;
      color: #4af;
      font-size: 0.8em;
      cursor: pointer;
      transition: all 0.3s ease;
      min-width: 60px;
    }
    
    /* Responsive Movement Buttons */
    @media (max-width: 1200px) {
      .movement-btn {
        font-size: 0.7em;
        padding: 3px 6px;
        min-width: 50px;
      }
    }
    
    @media (max-width: 768px) {
      .movement-btn {
        font-size: 0.6em;
        padding: 2px 4px;
        min-width: 40px;
      }
    }
    
    @media (max-width: 480px) {
      .movement-btn {
        font-size: 0.5em;
        padding: 2px 3px;
        min-width: 35px;
      }
    }

    .movement-btn:hover:not(:disabled) {
      background-color: #4af;
      color: #222;
    }

    .movement-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
      border-color: #666;
      color: #666;
    }

    .movement-btn-active {
      background-color: #ffc107 !important;
      border-color: #ffc107 !important;
      color: #212529 !important;
    }

    /* Suction parameter inputs */
    .suction-input {
      width: 50px;
      background: #222;
      color: #4af;
      border: 1px solid #4af;
      padding: 2px;
      text-align: center;
      font-size: 0.7em;
    }

    /* Action Plan Visualization Styles */
    .action-sequence {
      display: flex;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      gap: 8px;
      padding: 4px;
    }
    
    .action-step {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 4px;
      padding: 6px;
      background: #222;
      border: 1px solid #4af;
      border-radius: 6px;
      min-width: 80px;
      transition: all 0.5s ease;
    }
    
    .action-arrow {
      color: #4af;
      font-size: 1.5em;
      font-weight: bold;
      margin: 0 4px;
      text-shadow: 0 0 4px #4af;
      animation: arrowGlow 2s ease-in-out infinite alternate;
    }
    
    @keyframes arrowGlow {
      from { text-shadow: 0 0 4px #4af; }
      to { text-shadow: 0 0 8px #4af, 0 0 12px #4af; }
    }
    
    .action-step:hover {
      background: #333;
      border-color: #6cf;
      transform: scale(1.05);
    }
    
    .action-step.completed {
      border-color: #28a745;
      background: #1a3d1a;
    }
    
    .action-step.current {
      border-color: #ffc107;
      background: #3d3d1a;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0.7); }
      70% { box-shadow: 0 0 0 10px rgba(255, 193, 7, 0); }
      100% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0); }
    }
    
    .action-icon {
      width: 32px;
      height: 32px;
      margin-bottom: 4px;
      filter: brightness(0.8);
    }
    
    .action-step:hover .action-icon {
      filter: brightness(1.2);
    }
    
    .action-step.completed .action-icon {
      filter: brightness(1) hue-rotate(120deg);
    }
    
    .action-step.current .action-icon {
      filter: brightness(1.3) hue-rotate(45deg);
    }
    
    .action-label {
      font-size: 0.7em;
      color: #ccc;
      text-align: center;
      font-weight: bold;
      text-transform: uppercase;
    }
    
    .action-object {
      font-size: 0.6em;
      color: #888;
      text-align: center;
      margin-top: 2px;
      max-width: 70px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .action-coordinates {
      font-size: 0.5em;
      color: #666;
      text-align: center;
      margin-top: 1px;
      font-family: monospace;
    }
    
    /* Responsive Action Plan */
    @media (max-width: 1200px) {
      .action-step {
        min-width: 70px;
        padding: 4px;
      }
      .action-icon {
        width: 28px;
        height: 28px;
      }
      .action-label {
        font-size: 0.65em;
      }
      .action-object {
        font-size: 0.55em;
        max-width: 60px;
      }
      .action-arrow {
        font-size: 1.3em;
        margin: 0 3px;
      }
    }
    
    @media (max-width: 768px) {
      .action-sequence {
        gap: 4px;
      }
      .action-step {
        min-width: 60px;
        padding: 3px;
      }
      .action-icon {
        width: 24px;
        height: 24px;
      }
      .action-label {
        font-size: 0.6em;
      }
      .action-object {
        font-size: 0.5em;
        max-width: 50px;
      }
      .action-coordinates {
        display: none; /* Hide coordinates on mobile */
      }
      .action-arrow {
        font-size: 1.1em;
        margin: 0 2px;
      }
    }
    
    @media (max-width: 480px) {
      #actionPlanContainer {
        gap: 4px;
      }
      .action-sequence {
        gap: 2px;
        flex-direction: column; /* Stack vertically on very small screens */
        align-items: center;
      }
      .action-step {
        min-width: 50px;
        padding: 2px;
      }
      .action-icon {
        width: 20px;
        height: 20px;
      }
      .action-label {
        font-size: 0.55em;
      }
      .action-object {
        font-size: 0.45em;
        max-width: 45px;
      }
      .action-arrow {
        font-size: 1em;
        margin: 2px 0;
        transform: rotate(90deg); /* Vertical arrows for vertical layout */
      }
    }

    /* Responsive Instructions Area */
    @media (max-width: 1200px) {
      .instructions-area {
        font-size: 0.85em;
      }
      .instructions-title {
        font-size: 1em;
      }
    }
    
    @media (max-width: 768px) {
      .instructions-area {
        font-size: 0.8em;
        padding: 8px;
        margin-top: 20px;
      }
      .instructions-title {
        font-size: 0.95em;
      }
    }
    
    @media (max-width: 480px) {
      .instructions-area {
        font-size: 0.75em;
        padding: 6px;
        margin-top: 15px;
      }
      .instructions-title {
        font-size: 0.9em;
      }
    }
  </style>
</head>
<body class="bg-gray-900 text-green-300">

<div id="dashboard">
  <!-- Row1, Col1: Camera Outputs (Segmentation and Depth side by side) -->
  <div class="panel" style="grid-row:1; grid-column:1; display:flex; flex-direction:row; padding:0;">
    <!-- Segmentation Output -->
    <div id="segContainer" class="media-container" style="flex:1; border-right:1px solid #333;">
      <div class="panel-title">Segmentation</div>
      <video id="segVideo" class="media-content" autoplay muted playsinline></video>
      <img id="segImg" class="media-content" src="https://via.placeholder.com/320x180?text=Seg" alt="SegOutput" style="display:none;">
    </div>
    <!-- Depth Output -->
    <div id="depthContainer" class="media-container" style="flex:1;">
      <div class="panel-title">Depth</div>
      <img id="depthImg" class="media-content" src="https://via.placeholder.com/320x180?text=Depth" alt="DepthOutput">
      <select id="depthMode" style="position:absolute; top:8px; right:8px; z-index:5;"></select>
    </div>
  </div>

  <!-- Row1, Col2: Robot Control (Top 50% only) + Empty Space (50%) -->
  <div class="panel" style="grid-row:1; grid-column:2; display:flex; flex-direction:column; padding:8px;">
    <div class="panel-title">Robot Control</div>
    
    <!-- Top 50%: Robot Controls -->
    <div style="height:50%; border-bottom:1px solid #444; padding-bottom:8px; margin-bottom:8px; display:flex;">
      <!-- Left 80%: All Controls -->
      <div style="width:80%; display:flex; flex-direction:column; padding-right:8px;">
        
      <!-- Row 1: Robot Status Section -->
      <div style="display:flex; gap:8px; align-items:center; justify-content:center; margin-bottom:6px;">
        <button id="robotInitBtn" class="robot-btn robot-btn-red" onclick="initializeRobot(true)">
          Initialize (Headless)
        </button>
        <button id="robotInteractiveBtn" class="robot-btn robot-btn-red" onclick="initializeRobot(false)">
          Initialize (Interactive)
        </button>
      </div>
      <div style="text-align:center; margin-bottom:6px;">
        <div id="robotStatus" style="font-size:0.8em; color:#ccc;">Robot not initialized</div>
        <div style="font-size:0.7em; color:#888; margin-top:2px;">
          <strong>Headless:</strong> Dashboard controls only (1920x1080)<br>
          <strong>Interactive:</strong> Browser window + Dashboard controls
        </div>
      </div>
        
        <!-- Row 2: Distance Input and Movement Controls -->
        <div style="display:flex; gap:8px; align-items:center; justify-content:center; margin-bottom:6px;">
          <!-- Distance Input -->
          <div style="display:flex; align-items:center; gap:4px;">
            <label style="color:#4af; font-size:0.8em;">Distance:</label>
            <input type="number" id="moveDistance" value="20" min="1" max="500" 
                  style="width:50px; background:#222; color:#4af; border:1px solid #4af; padding:2px; text-align:center; font-size:0.8em;">
            <span style="color:#4af; font-size:0.8em;">mm</span>
          </div>
          
          <!-- Movement Controls Grid -->
          <div style="display:grid; grid-template-columns:1fr 1fr 1fr; grid-template-rows:1fr 1fr 1fr; gap:2px; width:120px;">
            <div></div>
            <button id="moveUpBtn" class="movement-btn" onclick="moveRobot('up')" disabled style="font-size:0.7em;">‚Üë</button>
            <div></div>
            
            <button id="moveLeftBtn" class="movement-btn" onclick="moveRobot('left')" disabled style="font-size:0.7em;">‚Üê</button>
            <div></div>
            <button id="moveRightBtn" class="movement-btn" onclick="moveRobot('right')" disabled style="font-size:0.7em;">‚Üí</button>
            
            <div></div>
            <button id="moveDownBtn" class="movement-btn" onclick="moveRobot('down')" disabled style="font-size:0.7em;">‚Üì</button>
            <div></div>
          </div>
        </div>
        
        <!-- Row 3: Action Buttons -->
        <div style="display:flex; gap:4px; justify-content:center; margin-bottom:6px;">
          <button id="moveForwardBtn" class="movement-btn" onclick="moveRobot('forward')" disabled style="font-size:0.7em;">‚Üó Forward</button>
          <button id="moveBackBtn" class="movement-btn" onclick="moveRobot('back')" disabled style="font-size:0.7em;">‚Üô Back</button>
          <button id="getPositionBtn" class="movement-btn" onclick="getRobotPosition()" disabled style="font-size:0.7em;">Get Pos</button>
          <button id="suctionOnBtn" class="movement-btn" onclick="openSuctionModal()" disabled style="font-size:0.7em;">Suct On</button>
          <button id="suctionOffBtn" class="movement-btn" onclick="suctionOff()" disabled style="font-size:0.7em;">Suct Off</button>
          <button id="homeBtn" class="movement-btn" onclick="moveToHome()" disabled style="font-size:0.7em;">Home</button>
        </div>
        
        <!-- Row 4: Suction Parameters -->
        <div style="display:flex; gap:6px; align-items:center; justify-content:center; margin-bottom:6px;">
          <div style="display:flex; align-items:center; gap:2px;">
            <label style="color:#4af; font-size:0.7em;">Load:</label>
            <input type="number" id="suctionLoad" value="1000" min="0" max="2000" class="suction-input">
          </div>
          <div style="display:flex; align-items:center; gap:2px;">
            <label style="color:#4af; font-size:0.7em;">Vacuum:</label>
            <input type="number" id="suctionVacuum" value="650" min="550" max="750" class="suction-input">
          </div>
          <div style="display:flex; align-items:center; gap:2px;">
            <label style="color:#4af; font-size:0.7em;">Timeout:</label>
            <input type="number" id="suctionTimeout" value="5.0" min="0.5" max="10" step="0.1" class="suction-input">
          </div>
        </div>
        
        <!-- Row 5: Stop Button -->
        <div style="text-align:center;">
          <button id="robotStopBtn" class="robot-btn robot-btn-gray" onclick="stopRobot()" disabled style="font-size:0.8em;">
            Stop Robot
          </button>
        </div>
        
      </div>
      
      <!-- Right 20%: Position Display (90% height, centered) -->
      <div style="width:20%; display:flex; align-items:center;">
        <div style="width:100%; height:90%; background:#111; border:1px solid #4af; padding:6px; font-family:monospace; font-size:1.2em; line-height:1.3;">
          <div style="color:#4af; font-weight:bold; margin-bottom:6px; font-size:0.8em; text-align:center;">Robot Position:</div>
          <div id="positionDisplay" style="color:#ccc;">
            <div>X: --- mm</div>
            <div>Y: --- mm</div>
            <div>Z: --- mm</div>
            <div>RX: --- ¬∞</div>
            <div>RY: --- ¬∞</div>
            <div>RZ: --- ¬∞</div>
          </div>
        </div>
      </div>
      
    </div>
    
    <!-- Bottom 50%: Action Plan Visualization -->
    <div id="actionPlanArea" style="height:50%; background:#1a1a1a; border:1px solid #333; border-radius:4px; display:flex; flex-direction:column; padding:8px;">
      <div style="color:#4af; font-weight:bold; font-size:0.9em; margin-bottom:8px; text-align:center;">
        Action Plan Visualization
      </div>
      <div id="actionPlanContainer" style="flex:1; display:flex; flex-wrap:wrap; align-items:center; justify-content:center; gap:8px; overflow-y:auto;">
        <div id="actionPlanPlaceholder" style="color:#666; font-style:italic; font-size:1em;">
          Action plan will appear here
        </div>
      </div>
    </div>
  </div>

  <!-- Row2, Col1: Chat -->
  <div class="panel" style="grid-row:2; grid-column:1;">
    <div class="panel-title">Chat</div>
    <!-- Welcome/Instructions Area (larger) -->
    <div class="instructions-area">
      <div class="instructions-title">ü§ñ Max Intelligent Robot Assistant</div>
      <div class="instructions-content">
        <strong>Welcome!</strong> I can help you with:<br>
        ‚Ä¢ <strong>Pick objects:</strong> "Pick the red cup on the left"<br>
        ‚Ä¢ <strong>Place objects:</strong> "Place it in the dishwasher"<br>
        ‚Ä¢ <strong>Multi-step:</strong> "Pick the cup and place it on the table"<br>
        ‚Ä¢ <strong>Chat & ask questions</strong> about what I can see<br>
        <em style="color:#4af;">üí° Tip: Be specific about objects and locations!</em>
      </div>
    </div>
    <!-- Chat Messages Area (remaining space) -->
    <div id="chatMessages" style="flex:1; height:calc(70% - 60px);"></div>
    <div style="margin-top:8px; display:flex;">
      <input type="text" id="chatInput" class="bg-gray-800 text-green-300 border border-green-500 px-2 py-1 flex-1" placeholder="Type command...">
      <button id="chatSendBtn" class="neon-btn chat-send-btn" style="margin-left:8px;">Send</button>
    </div>
  </div>

  <!-- Row2, Col2: LLM Reasoning -->
  <div class="panel" style="grid-row:2; grid-column:2; display:flex; flex-direction:column;">
    <div class="panel-title">LLM Reasoning</div>
    <div id="llmConsole" class="console-area" style="margin-top:30px;"></div>
  </div>
</div>

<script>
  /****************************************************
   * ELEMENT REFS
   ****************************************************/
  const segVideo     = document.getElementById("segVideo");
  const segImg       = document.getElementById("segImg");
  const segContainer = document.getElementById("segContainer");
  const depthMode    = document.getElementById("depthMode");
  const depthImg     = document.getElementById("depthImg");
  const chatMessages = document.getElementById("chatMessages");
  const chatInput    = document.getElementById("chatInput");
  const chatSendBtn  = document.getElementById("chatSendBtn");
  const llmConsole   = document.getElementById("llmConsole");

  /****************************************************
   * ENHANCED ERROR HANDLING UTILITIES
   ****************************************************/
  async function getDetailedErrorInfo(response, operation) {
    const errorInfo = {
      operation: operation,
      status: response?.status || 'Unknown',
      statusText: response?.statusText || 'Unknown',
      url: response?.url || 'Unknown',
      type: response?.type || 'Unknown',
      headers: {},
      body: null
    };

    try {
      // Get headers
      if (response?.headers) {
        for (let [key, value] of response.headers.entries()) {
          errorInfo.headers[key] = value;
        }
      }
      
      // Try to get response body
      if (response && !response.bodyUsed) {
        try {
          errorInfo.body = await response.text();
        } catch (e) {
          errorInfo.body = `Could not read response body: ${e.message}`;
        }
      }
    } catch (e) {
      errorInfo.extractionError = e.message;
    }

    return errorInfo;
  }

  function logDetailedError(error, operation, response = null) {
    console.error(`‚ùå DETAILED ERROR for ${operation}:`, {
      errorMessage: error.message,
      errorType: error.constructor.name,
      stack: error.stack,
      response: response,
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      url: window.location.href
    });
  }

  function formatErrorForUser(errorInfo) {
    let message = `[${errorInfo.operation}] `;
    
    if (errorInfo.status === 'Unknown') {
      message += `Connection failed - unable to reach server. `;
      message += `URL: ${errorInfo.url}`;
    } else {
      message += `HTTP ${errorInfo.status} ${errorInfo.statusText}. `;
      if (errorInfo.body && errorInfo.body.length < 200) {
        message += `Response: ${errorInfo.body}`;
      } else if (errorInfo.body) {
        message += `Response: ${errorInfo.body.substring(0, 200)}...`;
      }
    }
    
    return message;
  }

  /****************************************************
   * STATE
   ****************************************************/
  let segFrozen          = false;
  let isSegmenting       = false;
  let realsenseSegTimer  = null;
  let depthTimer         = null;
  let realsenseAvailable = false;
  let robotStatusTimer   = null;

  /****************************************************
   * ROBOT CONTROL FUNCTIONS
   ****************************************************/

  // Start monitoring robot status
  function startRobotStatusMonitoring() {
    if (robotStatusTimer) return;
    
    robotStatusTimer = setInterval(async () => {
      try {
        const resp = await fetch("/robot/status");
        if (resp.ok) {
          const status = await resp.json();
          updateRobotUI(status);
        }
      } catch (e) {
        console.error("Robot status check failed:", e);
      }
    }, 1000); // Check every second
  }

  // Stop monitoring robot status  
  function stopRobotStatusMonitoring() {
    if (robotStatusTimer) {
      clearInterval(robotStatusTimer);
      robotStatusTimer = null;
    }
  }

  // Enhanced move robot function with custom distance
  async function moveRobot(direction) {
    try {
      // Get distance from input field
      const distanceInput = document.getElementById("moveDistance");
      const distance = parseInt(distanceInput.value) || 20;
      
      // Validate distance
      if (distance < 1 || distance > 500) {
        addChatMessage("Max", `Invalid distance: ${distance}mm. Must be between 1-500mm.`);
        return;
      }
      
      // Set button to active state
      const btnId = `move${direction.charAt(0).toUpperCase() + direction.slice(1)}Btn`;
      const btn = document.getElementById(btnId);
      if (btn) {
        btn.classList.add("movement-btn-active");
      }
      
      const resp = await fetch(`/robot/move/${direction}`, { 
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ distance: distance })
      });
      
      if (resp.ok) {
        console.log(`Robot moving ${direction} ${distance}mm`);
        addChatMessage("Max", `Moving robot ${direction} (${distance}mm)`);
      } else {
        const error = await resp.json();
        addChatMessage("Max", `Robot movement failed: ${error.error}`);
        // Remove active state on error
        if (btn) {
          btn.classList.remove("movement-btn-active");
        }
      }
    } catch (e) {
      console.error("Robot movement error:", e);
      addChatMessage("Max", `Robot movement error: ${e.message}`);
    }
  }

  // Get robot position function
  async function getRobotPosition() {
    try {
      addChatMessage("Max", "Getting robot position...");
      
      const resp = await fetch("/robot/position", { method: "GET" });
      if (resp.ok) {
        const position = await resp.json();
        updatePositionDisplay(position);
        addChatMessage("Max", "Robot position updated!");
      } else {
        const error = await resp.json();
        addChatMessage("Max", `Get position failed: ${error.error}`);
      }
    } catch (e) {
      console.error("Get position error:", e);
      addChatMessage("Max", `Get position error: ${e.message}`);
    }
  }

  // Update position display
  function updatePositionDisplay(position) {
    const display = document.getElementById("positionDisplay");
    if (position && position.pos_x !== undefined) {
      display.innerHTML = `
        <div>X: ${Math.round(position.pos_x)} mm</div>
        <div>Y: ${Math.round(position.pos_y)} mm</div>
        <div>Z: ${Math.round(position.pos_z)} mm</div>
        <div>RX: ${Math.round(position.rot_x)}¬∞</div>
        <div>RY: ${Math.round(position.rot_y)}¬∞</div>
        <div>RZ: ${Math.round(position.rot_z)}¬∞</div>
      `;
    } else {
      display.innerHTML = `
        <div>X: --- mm</div>
        <div>Y: --- mm</div>
        <div>Z: --- mm</div>
        <div>RX: --- ¬∞</div>
        <div>RY: --- ¬∞</div>
        <div>RZ: --- ¬∞</div>
      `;
    }
  }

  // Open suction modal/parameters and execute
  async function openSuctionModal() {
    try {
      // Get values from inputs
      const load = parseInt(document.getElementById("suctionLoad").value);
      const vacuum = parseInt(document.getElementById("suctionVacuum").value);
      const timeout = parseFloat(document.getElementById("suctionTimeout").value);
      
      addChatMessage("Max", `Turning suction on with Load: ${load}, Vacuum: ${vacuum}, Timeout: ${timeout}s...`);
      
      const resp = await fetch("/robot/suction/on", { 
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ load: load, vacuum: vacuum, timeout: timeout })
      });
      
      if (resp.ok) {
        addChatMessage("Max", "Suction activated successfully!");
      } else {
        const error = await resp.json();
        addChatMessage("Max", `Suction on failed: ${error.error}`);
      }
    } catch (e) {
      console.error("Suction on error:", e);
      addChatMessage("Max", `Suction on error: ${e.message}`);
    }
  }

  // Suction off function
  async function suctionOff() {
    try {
      addChatMessage("Max", "Turning suction off...");
      
      const resp = await fetch("/robot/suction/off", { method: "POST" });
      if (resp.ok) {
        addChatMessage("Max", "Suction deactivated successfully!");
      } else {
        const error = await resp.json();
        addChatMessage("Max", `Suction off failed: ${error.error}`);
      }
    } catch (e) {
      console.error("Suction off error:", e);
      addChatMessage("Max", `Suction off error: ${e.message}`);
    }
  }

  // Move to home function
  async function moveToHome() {
    try {
      addChatMessage("Max", "Moving robot to home position...");
      
      const resp = await fetch("/robot/home", { method: "POST" });
      if (resp.ok) {
        addChatMessage("Max", "Robot moved to home position successfully!");
      } else {
        const error = await resp.json();
        addChatMessage("Max", `Move to home failed: ${error.error}`);
      }
    } catch (e) {
      console.error("Move to home error:", e);
      addChatMessage("Max", `Move to home error: ${e.message}`);
    }
  }

  // Enhanced input validation for all fields
  document.addEventListener("DOMContentLoaded", function() {
    // Distance input validation
    const distanceInput = document.getElementById("moveDistance");
    if (distanceInput) {
      distanceInput.addEventListener("input", function() {
        let value = parseInt(this.value);
        if (isNaN(value) || value < 1) {
          this.value = 1;
        } else if (value > 500) {
          this.value = 500;
        }
      });
      
      distanceInput.addEventListener("blur", function() {
        if (!this.value) {
          this.value = 20; // Default back to 20
        }
      });
    }

    // Suction parameter validation
    const suctionLoad = document.getElementById("suctionLoad");
    if (suctionLoad) {
      suctionLoad.addEventListener("input", function() {
        let value = parseInt(this.value);
        if (isNaN(value) || value < 0) {
          this.value = 0;
        } else if (value > 2000) {
          this.value = 2000;
        }
      });
    }

    const suctionVacuum = document.getElementById("suctionVacuum");
    if (suctionVacuum) {
      suctionVacuum.addEventListener("input", function() {
        let value = parseInt(this.value);
        if (isNaN(value) || value < 550) {
          this.value = 550;
        } else if (value > 750) {
          this.value = 750;
        }
      });
    }

    const suctionTimeout = document.getElementById("suctionTimeout");
    if (suctionTimeout) {
      suctionTimeout.addEventListener("input", function() {
        let value = parseFloat(this.value);
        if (isNaN(value) || value < 0.5) {
          this.value = 0.5;
        } else if (value > 10) {
          this.value = 10;
        }
      });
    }
  });

  // Initialize robot with headless parameter
  async function initializeRobot(headless = true) {
    try {
      const modeText = headless ? "headless" : "interactive";
      addChatMessage("Max", `ü§ñ Starting robot initialization in ${modeText} mode...`);
      
      const resp = await fetch("/robot/initialize", { 
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ headless: headless })
      });
      
      if (resp.ok) {
        console.log(`Robot ${modeText} initialization started`);
        if (!headless) {
          addChatMessage("Max", "üåê Browser window should open shortly with Franka Desk interface!");
          addChatMessage("Max", "üéÆ Dashboard control buttons will be enabled once ready.");
          addChatMessage("Max", "üí° You can use BOTH the browser interface AND the dashboard buttons!");
        } else {
          addChatMessage("Max", "ü§ñ Headless mode - 1920x1080 viewport, dashboard controls only");
        }
      } else {
        const error = await resp.json();
        addChatMessage("Max", `Robot initialization failed: ${error.error}`);
      }
    } catch (e) {
      console.error("Robot initialization error:", e);
      addChatMessage("Max", `Robot initialization error: ${e.message}`);
    }
  }

  // Updated robot status function to show mode
  function updateRobotUI(status) {
    const initBtn = document.getElementById("robotInitBtn");
    const interactiveBtn = document.getElementById("robotInteractiveBtn");
    const statusDiv = document.getElementById("robotStatus");
    const stopBtn = document.getElementById("robotStopBtn");
    
    // Update status message
    statusDiv.textContent = status.message;
    
    // Update init buttons
    initBtn.className = "robot-btn ";
    interactiveBtn.className = "robot-btn ";
    
    switch (status.state) {
      case "disconnected":
        initBtn.className += "robot-btn-red";
        initBtn.textContent = "Initialize (Headless)";
        initBtn.disabled = false;
        interactiveBtn.className += "robot-btn-red";
        interactiveBtn.textContent = "Initialize (Interactive)";
        interactiveBtn.disabled = false;
        stopBtn.disabled = true;
        break;
      case "initializing":
        initBtn.className += "robot-btn-yellow";
        initBtn.textContent = "Initializing...";
        initBtn.disabled = true;
        interactiveBtn.className += "robot-btn-yellow";
        interactiveBtn.textContent = "Initializing...";
        interactiveBtn.disabled = true;
        stopBtn.disabled = false;
        break;
      case "ready":
        initBtn.className += "robot-btn-green";
        initBtn.textContent = "Robot Ready";
        initBtn.disabled = true;
        interactiveBtn.className += "robot-btn-green";
        interactiveBtn.textContent = "Robot Ready";
        interactiveBtn.disabled = true;
        stopBtn.disabled = false;
        break;
      case "moving":
        // Keep ready state buttons but show moving status
        initBtn.className += "robot-btn-green";
        initBtn.textContent = "Robot Ready";
        initBtn.disabled = true;
        interactiveBtn.className += "robot-btn-green";
        interactiveBtn.textContent = "Robot Ready";
        interactiveBtn.disabled = true;
        stopBtn.disabled = false;
        break;
      case "error":
        initBtn.className += "robot-btn-red";
        initBtn.textContent = "Error - Retry (H)";
        initBtn.disabled = false;
        interactiveBtn.className += "robot-btn-red";
        interactiveBtn.textContent = "Error - Retry (I)";
        interactiveBtn.disabled = false;
        stopBtn.disabled = false;
        break;
    }
    
    // Update ALL control buttons
    const controlButtons = [
      "moveUpBtn", "moveDownBtn", "moveLeftBtn", "moveRightBtn", 
      "moveForwardBtn", "moveBackBtn", "getPositionBtn", 
      "suctionOnBtn", "suctionOffBtn", "homeBtn"
    ];
    
    controlButtons.forEach(btnId => {
      const btn = document.getElementById(btnId);
      if (btn) {
        btn.disabled = !status.buttons_enabled || status.state === "moving";
        
        // Remove active state if not moving
        if (status.state !== "moving") {
          btn.classList.remove("movement-btn-active");
        }
      }
    });
  }


  // Stop robot
  async function stopRobot() {
    try {
      const resp = await fetch("/robot/stop", { method: "POST" });
      if (resp.ok) {
        addChatMessage("Max", "Robot stopped and disconnected");
      } else {
        const error = await resp.json();
        addChatMessage("Max", `Robot stop failed: ${error.error}`);
      }
    } catch (e) {
      console.error("Robot stop error:", e);
      addChatMessage("Max", `Robot stop error: ${e.message}`);
    }
  }

  /****************************************************
   * PAGE LOAD
   ****************************************************/
  window.addEventListener("DOMContentLoaded", async () => {
      // Start robot monitoring
      startRobotStatusMonitoring();

      // Fetch camera info to check RealSense availability
      try {
        const res = await fetch("/camera_info");
        const info = await res.json();
        realsenseAvailable = info.realsense_available;
        console.log("RealSense available:", realsenseAvailable);
      } catch (e) {
        realsenseAvailable = false;
        console.error("Error checking camera info:", e);
        logDetailedError(e, "Camera Info Check");
        addChatMessage("Max", "Error checking RealSense availability. Functionality may be limited.");
      }

      updateDepthDropdown();

      // Automatically start RealSense for segmentation if available
      if (realsenseAvailable) {
        startRealSenseSeg();
        // Start depth processing with default option
        depthMode.value = "realsense_rgb_anything";
        depthTimer = setInterval(() => processDepth(depthMode.value), 500);
      } else {
        addChatMessage("Max", "RealSense not detected. Segmentation and Depth will be inactive.");
      }
      
      // Add welcome message about robot initialization
      addChatMessage("Max", "ü§ñ Ready! Use the robot control buttons to initialize in headless or interactive mode.");
    });

  /****************************************************
   * SEGMENTATION - RealSense Only
   ****************************************************/
  function startRealSenseSeg() {
    segVideo.style.display = "none";
    segImg.style.display = "block";
    realsenseSegTimer = setInterval(fetchRealsenseSeg, 250);
    console.log("Starting RealSense for segmentation.");
  }

  async function fetchRealsenseSeg() {
    try {
      const resp = await fetch("/process_realsense_seg", { method: "POST" });
      if (!resp.ok) {
        const errorInfo = await getDetailedErrorInfo(resp, "RealSense Segmentation");
        console.error("RealSense fetch error details:", errorInfo);
        throw new Error(`Failed to fetch RealSense frame: ${resp.status} ${resp.statusText}`);
      }
      const d = await resp.json();
      if (d.frame) segImg.src = "data:image/jpeg;base64," + d.frame;
    } catch (e) {
      console.error("RealSense fetch error:", e);
      logDetailedError(e, "RealSense Segmentation");
    }
  }

  // Freeze the Seg window ‚Äî no more frames will arrive until we unfreeze
  function freezeSegWindow(base64Frame) {
      segFrozen = true;
      isSegmenting = false; // Ensure it's not marked as segmenting to allow future clicks
      if (realsenseSegTimer) {
          clearInterval(realsenseSegTimer);
          realsenseSegTimer = null;
          console.log("Cleared RealSense timer to prevent frame updates. Timer ID: null");
      }

      // Swap to frozen JPEG
      segImg.src = "data:image/jpeg;base64," + base64Frame;
      segVideo.style.display = "none";
      segImg.style.display = "block";
      console.log("Segmentation window frozen with captured frame. State: segFrozen=" + segFrozen + ", isSegmenting=" + isSegmenting + ", Timer: " + (realsenseSegTimer ? "Active" : "Cleared"));
  }

  // Unfreeze & resume RealSense feed
  function unfreezeSegWindow() {
      segFrozen = false;
      fetch("/reset_seg", { method: "POST" }).catch(e => {
        console.error("Reset seg error:", e);
        logDetailedError(e, "Reset Segmentation");
      });

      if (realsenseAvailable && !realsenseSegTimer) {
          realsenseSegTimer = setInterval(fetchRealsenseSeg, 250);
          console.log("Started RealSense timer for frame updates. Timer ID: " + realsenseSegTimer);
      }
      console.log("Segmentation window unfrozen. State: segFrozen=" + segFrozen + ", isSegmenting=" + isSegmenting + ", Timer: " + (realsenseSegTimer ? "Active" : "Not Started"));
  }

segContainer.addEventListener("click", async ev => {
    if (!realsenseAvailable) return;

    // FIRST CLICK: freeze and segment
    if (!segFrozen) {
        try {
            isSegmenting = true;
            console.log("First click: Capturing frame for segmentation. State before: segFrozen=" + segFrozen + ", isSegmenting=" + isSegmenting);
            const frameB64 = await captureSegFrame();
            freezeSegWindow(frameB64);

            // Get the image element and its bounding rectangle in the browser
            const imgElement = segImg.style.display !== "none" ? segImg : segVideo;
            const rr = imgElement.getBoundingClientRect();

            // Get the natural dimensions of the image (original size)
            const naturalWidth = imgElement.naturalWidth || imgElement.videoWidth || 640; // Fallback to expected width if unknown
            const naturalHeight = imgElement.naturalHeight || imgElement.videoHeight || 480; // Fallback to expected height if unknown

            // Compute the displayed dimensions and aspect ratio
            const displayedWidth = rr.width;
            const displayedHeight = rr.height;
            const aspectRatio = naturalWidth / naturalHeight;

            // Calculate the actual content area within the container (due to object-fit: contain)
            let contentWidth, contentHeight, offsetX, offsetY;
            if (displayedWidth / displayedHeight > aspectRatio) {
                // Image is constrained by height, black bars on sides
                contentHeight = displayedHeight;
                contentWidth = displayedHeight * aspectRatio;
                offsetX = (displayedWidth - contentWidth) / 2;
                offsetY = 0;
            } else {
                // Image is constrained by width, black bars on top/bottom
                contentWidth = displayedWidth;
                contentHeight = displayedWidth / aspectRatio;
                offsetY = (displayedHeight - contentHeight) / 2;
                offsetX = 0;
            }

            // Compute click position relative to the content area
            const clickX = ev.clientX - rr.left - offsetX;
            const clickY = ev.clientY - rr.top - offsetY;

            // Normalize click coordinates to the natural image dimensions
            const nx = (clickX / contentWidth) * naturalWidth;
            const ny = (clickY / contentHeight) * naturalHeight;

            // Ensure coordinates are within bounds
            const clampedNx = Math.max(0, Math.min(naturalWidth, nx)) / naturalWidth;
            const clampedNy = Math.max(0, Math.min(naturalHeight, ny)) / naturalHeight;

            console.log(`Click at normalized coords: (${clampedNx.toFixed(3)}, ${clampedNy.toFixed(3)}) based on natural size ${naturalWidth}x${naturalHeight}`);

            const resp = await fetch("/process_seg", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ frame: frameB64, clicked_x: clampedNx, clicked_y: clampedNy })
            });
            if (resp.ok) {
                const dd = await resp.json();
                if (dd.object_info) {
                    addChatMessage(
                        "Max",
                        `Center: ${dd.object_info.center_xyz_mm.map(v => Math.round(v)).join(', ')} mm; ` +
                        `distance ${dd.object_info.distance_m.toFixed(3)} m; ` +
                        `Size ${Math.round(dd.object_info.length_mm)}√ó${Math.round(dd.object_info.width_mm)} mm; ` +
                        `Orientation ${Math.round(dd.object_info.orientation_deg)}¬∞`
                    );
                }
                // Update overlay on frozen image - this now includes the verified circle
                segImg.src = "data:image/jpeg;base64," + dd.frame;
                console.log("Updated image with segmentation results and verified center point.");
            
            } else {
                const errorInfo = await getDetailedErrorInfo(resp, "Process Segmentation");
                console.error("Segmentation processing error:", errorInfo);
                addChatMessage("Max", `Segmentation error: ${formatErrorForUser(errorInfo)}`);
            }
        } catch (e) {
            console.error("Seg error:", e);
            logDetailedError(e, "Segmentation Click");
            addChatMessage("Max", `Segmentation error: ${e.message}`);
        } finally {
            isSegmenting = false;
            console.log("Segmentation complete. Final state: segFrozen=" + segFrozen + ", isSegmenting=" + isSegmenting);
        }
    }
    // SECOND CLICK: unfreeze
    else {
        unfreezeSegWindow();
    }
});

  /****************************************************
   * DEPTH
   ****************************************************/
  function updateDepthDropdown() {
    if (realsenseAvailable) {
      depthMode.innerHTML = `
        <option value="realsense_rgb_anything">RealSense RGB + Depth Anything</option>
        <option value="realsense_depth">RealSense Depth</option>
      `;
    } else {
      depthMode.innerHTML = `
        <option value="unavailable">Unavailable</option>
      `;
      depthMode.disabled = true;
      addChatMessage("Max", "RealSense not available. Depth options are disabled.");
    }
  }

  depthMode.addEventListener("change", () => {
    clearInterval(depthTimer);
    depthImg.src = "https://via.placeholder.com/320x180?text=Depth";
    const v = depthMode.value;
    if (realsenseAvailable && v !== "unavailable") {
      depthTimer = setInterval(() => processDepth(v), 500);
    }
  });

  async function processDepth(mode) {
    try {
      const r = await fetch("/process_depth", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ camera_mode: mode, local_idx: 0, frame: "" })
      });
      
      if (!r.ok) {
        const errorInfo = await getDetailedErrorInfo(r, "Depth Processing");
        console.error("Depth processing error:", errorInfo);
        return;
      }
      
      const d = await r.json();
      if (d.frame) depthImg.src = "data:image/jpeg;base64," + d.frame;
    } catch (e) {
      console.error("Depth processing error:", e);
      logDetailedError(e, "Depth Processing");
    }
  }

  /****************************************************
   * FRAME CAPTURE UTILS
   ****************************************************/
  function captureSegFrame() {
    return new Promise((res, rej) => {
      if (realsenseAvailable) {
        const p = segImg.src.split(",");
        p[1] ? res(p[1]) : rej("No RealSense frame");
      } else {
        rej("RealSense not available");
      }
    });
  }

  /****************************************************
   * CHAT
   ****************************************************/
  function addChatMessage(sender, msg) {
    if (chatMessages.children.length > 2000) chatMessages.removeChild(chatMessages.firstChild);
    const dv = document.createElement("div");
    dv.setAttribute("data-sender", sender); // Add data attribute for styling
    dv.innerHTML = `<strong>${sender}:</strong> ${msg}`;
    chatMessages.appendChild(dv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
  }

  async function sendChatStream(customText) {
      const userText = (customText || chatInput.value).trim();
      if (!userText) return;

      // Store current user message for results
      window.current_user_message = userText;
      // Don't set a fake path here - let the server provide the real one

      chatInput.value = "";
      addChatMessage("You", userText);

      // Clear reasoning window
      llmConsole.innerHTML = "";

      // Clear action plan visualization
      clearActionPlan();

      // Unfreeze segmentation window and reset state to ensure fresh frames
      unfreezeSegWindow();

      try {
          console.log("üîç Attempting streaming request...");
          const success = await tryStreamingChat(userText);

          if (!success) {
              console.log("üîÑ Streaming failed, trying non-streaming fallback...");
              await tryFallbackChat(userText);
          }
      } catch (error) {
          console.error("‚ùå Chat error:", error);
          logDetailedError(error, "Chat Stream");
          addChatMessage("Max", `Error: ${error.message}. Please try again.`);
      }
  }

  async function tryStreamingChat(userText) {
      try {
          console.log("üì§ Attempting fetch to /chat-stream");
          const resp = await fetch("/chat-stream", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ text: userText })
          });

          if (!resp.ok) {
              console.log(`‚ùå Streaming response not ok: ${resp.status}`);
              const errorInfo = await getDetailedErrorInfo(resp, "Chat Stream");
              console.error("Streaming error details:", errorInfo);
              addChatMessage("Max", `Chat streaming failed: ${formatErrorForUser(errorInfo)}`);
              return false;
          }

          const reader = resp.body.getReader();
          const decoder = new TextDecoder();
          let reasoning = "";
          let answer = "";
          let actionBuffer = "";

          while (true) {
              const { done, value } = await reader.read();
              if (done) break;

              const chunk = decoder.decode(value, { stream: true });
              const lines = chunk.split('\n');

              for (const line of lines) {
                  if (!line.trim()) continue;

                  if (line.startsWith("data: ")) {
                      let content = line.slice(6).trim();

                      if (content === "[DONE]") break;
                      // Handle thinking and response content
                      if (content.startsWith("thinking:")) {
                          const thinkingToken = content.slice(9);
                          // Add space if needed before appending token
                          if (reasoning && thinkingToken && needsSpace(reasoning, thinkingToken)) {
                              reasoning += " " + thinkingToken;
                          } else {
                              reasoning += thinkingToken;
                          }
                          llmConsole.innerHTML = reasoning;
                          llmConsole.scrollTop = llmConsole.scrollHeight;
                      } else if (content.startsWith("response:")) {
                          const responseToken = content.slice(9);
                          // PRESERVE newlines in action buffer
                          if (answer && responseToken && needsSpace(answer, responseToken)) {
                              answer += " " + responseToken;
                          } else {
                              answer += responseToken;
                          }
                          // For action buffer, preserve the raw token to maintain formatting
                          actionBuffer += responseToken;
                      } else {
                          // PRESERVE newlines in action buffer
                          if (answer && content && needsSpace(answer, content)) {
                              answer += " " + content;
                          } else {
                              answer += content;
                          }
                          // For action buffer, preserve the raw token to maintain formatting
                          actionBuffer += content;
                      }

                      // Check for [ACTION] in the accumulated buffer
                      if (actionBuffer.includes("[ACTION]")) {
                          console.log("‚úÖ [ACTION] block detected in streaming!");
                          const actionResult = extractAndProcessAction(actionBuffer);
                          if (actionResult.processed) {
                              actionBuffer = actionResult.remainingBuffer;
                              return true; // Exit early since action is being handled
                          }
                      }
                  }
              }
          }

          // After streaming, if no action was processed, show the response
          if (answer.trim() && !answer.includes("[ACTION]")) {
              console.log("‚úÖ No action detected, showing regular chat response.");
              addChatMessage("Max", answer.trim());
              return true;
          }

          // Final attempt to process action if present
          if (actionBuffer.includes("[ACTION]")) {
              console.log("‚úÖ [ACTION] detected at stream end, final processing attempt.");
              const actionResult = extractAndProcessAction(actionBuffer);
              if (actionResult.processed) {
                  return true;
              }
          }

          console.log("‚ùå No valid response or action processed.");
          return false;
      } catch (error) {
          console.error("‚ùå Streaming error:", error);
          logDetailedError(error, "Chat Stream Request");
          addChatMessage("Max", `Streaming error: ${error.message}`);
          return false;
      }
  }

  // Helper function to determine if a space is needed between two text fragments
  function needsSpace(existingText, newToken) {
      // If either string is empty, no space is needed
      if (!existingText || !newToken) return false;

      // Get the last character of existing text and first character of new token
      const lastChar = existingText.slice(-1);
      const firstChar = newToken[0];

      // If the last character is a space or punctuation, no additional space is needed
      if (/\s|[.,!?;]/.test(lastChar)) return false;

      // If the first character is a space or punctuation, no additional space is needed
      if (/\s|[.,!?;]/.test(firstChar)) return false;

      // If both characters are alphanumeric, a space is likely needed
      if (/[a-zA-Z0-9]/.test(lastChar) && /[a-zA-Z0-9]/.test(firstChar)) return true;

      // Default: no space needed (e.g., connecting symbols or mixed cases)
      return false;
  }

  function extractAndProcessAction(buffer) {
    const actionIndex = buffer.indexOf("[ACTION]");
    if (actionIndex === -1) {
      return { processed: false, remainingBuffer: buffer };
    }

    // Extract content after [ACTION]
    const actionContent = buffer.slice(actionIndex).trim();
    console.log("üîç Extracted [ACTION] content:", actionContent);

    // Split into lines for parsing
    const lines = actionContent.split('\n').filter(line => line.trim());
    console.log("üîç Lines in [ACTION] block:", lines);

    // If fewer than 2 lines, wait for more content
    if (lines.length < 2) {
      console.log("üîç Partial [ACTION] block, waiting for more content.");
      return { processed: false, remainingBuffer: buffer };
    }

    // Find the required lines - more flexible matching
    let roboPointLine = null;
    let actionLine = null;

    for (const line of lines) {
        // More flexible regex that handles "[ACTION]RoboPoint Request:" format
        if (!roboPointLine && /RoboPoint\s*Request\s*:/i.test(line)) {
            roboPointLine = line;
            console.log("‚úÖ Found RoboPoint line:", line);
        } else if (!actionLine && /Action\s*Request\s*:/i.test(line)) {
            actionLine = line;
            console.log("‚úÖ Found Action line:", line);
        }
    }

    // Better handling of combined lines
    if (!roboPointLine || !actionLine) {
        // Try to split a single combined line
        for (const line of lines) {
            if (line.includes("RoboPoint Request:") && line.includes("Action Request:")) {
                const parts = line.split(/Action\s*Request\s*:/i);
                if (parts.length === 2) {
                    roboPointLine = parts[0].trim();
                    actionLine = "Action Request:" + parts[1].trim();
                    console.log("‚úÖ Split combined line:", { roboPointLine, actionLine });
                    break;
                }
            }
        }
    }
    
    if (!actionLine) {
      for (const line of lines) {
        if (line.toLowerCase().includes("action") || line.toLowerCase().includes("pick") || line.toLowerCase().includes("place")) {
          actionLine = line;
          console.log("‚úÖ Found Action line (keyword match):", line);
          break;
        }
      }
    }

    // If still not found, report error but log full content for debugging
    if (!roboPointLine) {
      console.log("‚ùå Could not find RoboPoint Request line in:", lines);
      addChatMessage("Max", `Error: Missing 'RoboPoint Request:' line. Full response logged for debugging.`);
      addChatMessage("Max", `Debug content: ${actionContent.length > 200 ? actionContent.substring(0, 200) + '...' : actionContent}`);
      return { processed: false, remainingBuffer: buffer };
    }

    if (!actionLine) {
      console.log("‚ùå Could not find Action Request line in:", lines);
      addChatMessage("Max", `Error: Missing 'Action Request:' line. Full response logged for debugging.`);
      addChatMessage("Max", `Debug content: ${actionContent.length > 200 ? actionContent.substring(0, 200) + '...' : actionContent}`);
      return { processed: false, remainingBuffer: buffer };
    }

    // Process the action
    console.log("‚úÖ Complete [ACTION] block found, processing...");
    addChatMessage("Max", "ü§ñ Processing action request... Searching for objects.");
    executeMultiStepActions(actionContent);

    const remainingBuffer = buffer.slice(actionIndex + actionContent.length).trim();
    return { processed: true, remainingBuffer };
  }

  async function tryFallbackChat(userText) {
    try {
      addChatMessage("Max", "Processing your request...");
      console.log("üì§ Attempting fetch to /chat");
      const resp = await fetch("/chat", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ text: userText })
      });

      if (!resp.ok) {
        const errorInfo = await getDetailedErrorInfo(resp, "Chat Fallback");
        console.error("Fallback error details:", errorInfo);
        throw new Error(`Server error: ${formatErrorForUser(errorInfo)}`);
      }

      const data = await resp.json();
      console.log("üîç Fallback response:", data);

      const response = data.reply || data.answer || "";
      if (response) {
        if (response.includes("[ACTION]")) {
          console.log("‚úÖ [ACTION] detected in fallback response, processing...");
          addChatMessage("Max", "ü§ñ Processing action request... Searching for objects.");
          await executeMultiStepActions(response);
        } else {
          console.log("‚úÖ No action in fallback, showing regular response.");
          addChatMessage("Max", response);
        }
      } else {
        addChatMessage("Max", "No response received from fallback.");
      }
    } catch (error) {
      console.error("‚ùå Fallback error:", error);
      logDetailedError(error, "Chat Fallback");
      addChatMessage("Max", `Fallback error: ${error.message}`);
    }
  }

  async function executeMultiStepActions(actionBlock) {
      console.log("üîç DEBUG: Raw action block:", actionBlock);

      // Clear previous results
      window.robopoint_results = [];
      window.current_results = {
          user_message: window.current_user_message || "Unknown command",
          imagePath: "Unknown path",  // Will be updated with actual path
          objects: []
      };

    try {
        // Extract [ACTION] block content
        const actionMatch = actionBlock.match(/\[ACTION\]\s*([\s\S]*?)(?:\n\n|$)/i);
        if (!actionMatch) {
            throw new Error("Could not find [ACTION] block in response");
        }

        const content = actionMatch[1].trim();
        console.log("üîç DEBUG: Action content:", content);

        // Split into lines, handle single line with both requests
        let lines = content.split('\n').map(line => line.trim()).filter(line => line);
        if (lines.length === 1 && lines[0].includes("Action Request:")) {
            const idx = lines[0].indexOf("Action Request:");
            lines = [
                lines[0].slice(0, idx).trim(),
                lines[0].slice(idx).trim()
            ];
        }
        console.log("üîç DEBUG: All lines:", lines);

        let roboPointLine = null;
        let actionLines = [];  // ‚úÖ Changed to array to collect multiple action lines

        for (const line of lines) {
            if (line.match(/^\s*RoboPoint\s+Request\s*:/i)) {
                roboPointLine = line;
                console.log("‚úÖ Found RoboPoint line:", line);
            } else if (line.match(/^\s*Action\s+Request\s*:/i)) {
                actionLines.push(line);  // ‚úÖ Collect all action lines
                console.log("‚úÖ Found Action line:", line);
            }
        }

        // Detailed error reporting
        if (!roboPointLine) {
            console.log("‚ùå Available lines:", lines);
            addChatMessage("Max", `Error: Missing 'RoboPoint Request:' line.`);
            return;
        }

        if (actionLines.length === 0) {  // ‚úÖ Check if we have any action lines
            console.log("‚ùå Available lines:", lines);
            addChatMessage("Max", `Error: Missing 'Action Request:' line.`);
            return;
        }

        // Extract content after colons
        const roboPointContent = roboPointLine.split(':', 2)[1];

        // ‚úÖ Combine all action lines and parse them
        let allActionContent = "";
        if (actionLines.length === 1) {
            // Single line: might be "Pick; Place" or just "Pick"
            allActionContent = actionLines[0].split(':', 2)[1];
        } else {
            // Multiple lines: combine them with semicolons
            const actionParts = actionLines.map(line => line.split(':', 2)[1].trim());
            allActionContent = actionParts.join('; ');
        }

        if (!roboPointContent || !allActionContent) {
            addChatMessage("Max", "Error: Could not extract content from request/action lines");
            return;
        }

        // Parse the semicolon-separated values
        const objects = roboPointContent.split(';').map(s => s.trim()).filter(s => s);
        const actions = allActionContent.split(';').map(s => s.trim()).filter(s => s);

        console.log("üîç DEBUG: Parsed objects:", objects);
        console.log("üîç DEBUG: Parsed actions:", actions);

        if (objects.length !== actions.length) {
            addChatMessage("Max", `Error: Mismatch between objects (${objects.length}) and actions (${actions.length}).`);
            return;
        }

        if (objects.length === 0) {
            addChatMessage("Max", "Error: No valid commands found in the action block");
            return;
        }

        // Success - start processing
        addChatMessage("Max", `‚úÖ Found ${objects.length} command(s). Starting execution...`);

        // Unfreeze segmentation window to ensure fresh frames for RoboPoint actions
        unfreezeSegWindow();

        // Wait briefly to ensure a fresh frame is fetched
        await new Promise(resolve => setTimeout(resolve, 300));

        // Capture frame
        let frameB64 = "";
        try {
            frameB64 = await captureSegFrame();
            freezeSegWindow(frameB64);
        } catch (e) {
            console.warn("No seg frame:", e);
            addChatMessage("Max", "Warning: Could not capture frame. Continuing anyway...");
        }

        // Execute each command
for (let i = 0; i < objects.length; i++) {
            const object = objects[i];
            const action = actions[i];

            addChatMessage("Max", `üîÑ Step ${i+1}: Finding "${object}"...`);

            try {
                const result = await executeRoboPointCommand(object, action, frameB64);

                // Update image path with the actual saved path from the first result
                if (i === 0 && result.image_path) {
                    window.current_results.imagePath = result.image_path;
                    console.log(`üìÅ Updated image path: ${result.image_path}`);
                }

                if (result.seg_frame) {
                    segImg.src = "data:image/jpeg;base64," + result.seg_frame;
                    console.log("Updated image with RoboPoint results. State after: segFrozen=" + segFrozen + ", isSegmenting=" + isSegmenting);
                }

                // Collect result in the desired format
                if (result.object_info && result.object_info.center_xyz_mm) {
                    const info = result.object_info;
                    const objectResult = {
                        action: action.toLowerCase(),
                        location: result.placement || "unknown",
                        object: object,
                        object_center_location: {
                            x: Math.round(info.center_xyz_mm[0]),
                            y: Math.round(info.center_xyz_mm[1]),
                            z: Math.round(info.center_xyz_mm[2])
                        },
                        object_size: {
                            width: Math.round(info.width_mm),
                            length: Math.round(info.length_mm)
                        },
                        object_orientation: Math.round(info.orientation_deg)
                    };
                    
                    window.current_results.objects.push(objectResult);
                    
                    addChatMessage("Max", 
                        `‚úÖ Step ${i+1}: Successfully found "${object}"! Location: ${info.center_xyz_mm.map(v=>Math.round(v)).join(', ')} mm, Distance: ${info.distance_m.toFixed(3)} m, Size: ${Math.round(info.length_mm)}√ó${Math.round(info.width_mm)} mm, Orientation: ${Math.round(info.orientation_deg)}¬∞`
                    );
                } else {
                    // Add result even without detailed info
                    const objectResult = {
                        action: action.toLowerCase(),
                        location: result.placement || "unknown",
                        object: object,
                        object_center_location: { x: 0, y: 0, z: 0 },
                        object_size: { width: 0, length: 0 },
                        object_orientation: 0
                    };
                    window.current_results.objects.push(objectResult);
                    addChatMessage("Max", `‚úÖ Step ${i+1}: Successfully found "${object}"`);
                }

                // Pause between steps
                if (i < objects.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 800));
                }
            } catch (error) {
                console.error(`‚ùå Step ${i+1} failed:`, error);
                addChatMessage("Max", `‚ùå Step ${i+1} Failed: ${error.message}`);
                break;
            }
        }

        // Print final results to console
        console.log("ü§ñ ROBOPOINT RESULTS:");
        console.log("=".repeat(50));
        console.log(JSON.stringify(window.current_results, null, 2));
        console.log("=".repeat(50));

        addChatMessage("Max", `üéâ Completed ${objects.length} action(s)!`);
        
        // Call exec_planner with streaming output to LLM Reasoning panel
        addChatMessage("Max", "üöÄ Sending results to Max Planner for robot execution...");
        try {
            await callExecPlannerStream(window.current_results);
        } catch (error) {
            console.error("‚ùå Failed to call exec_planner_stream:", error);
            addChatMessage("Max", `‚ùå Failed to call Max Planner: ${error.message}`);
        }
        
        // Keep the segmentation window frozen to show results
        console.log("Keeping segmentation window frozen to show results. Click or send a new message to unfreeze. State: segFrozen=" + segFrozen + ", isSegmenting=" + isSegmenting + ", Timer: " + (realsenseSegTimer ? "Active" : "Cleared"));
    } catch (error) {
        console.error("‚ùå Action parsing error:", error);
        logDetailedError(error, "Action Parsing");
        addChatMessage("Max", `Action parsing error: ${error.message}`);
        unfreezeSegWindow();
    }
}

  async function executeRoboPointCommand(objectDescription, action, frameB64, retries = 2) {
      const singleActionBlock = `[ACTION]\nRoboPoint Request: ${objectDescription}\nAction Request: ${action}`;
      
      for (let attempt = 1; attempt <= retries; attempt++) {
          console.log(`üì§ Attempt ${attempt}: Sending to RoboPoint:`, singleActionBlock);
          
          try {
              const resp = await fetch("/exec_action", {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                      action_block: singleActionBlock,
                      seg_frame: frameB64
                  }),
                  timeout: 90000 // 90 second timeout
              });

              if (!resp.ok) {
                  const errorInfo = await getDetailedErrorInfo(resp, "Execute RoboPoint Command");
                  console.error(`Attempt ${attempt} failed:`, errorInfo);
                  if (attempt === retries) {
                      throw new Error(formatErrorForUser(errorInfo));
                  }
                  continue;
              }

              const result = await resp.json();
              console.log("üì• RoboPoint result:", result);
              
              if (result.error) {
                  throw new Error(`RoboPoint server error: ${result.error}`);
              }
              
              return result;
          } catch (error) {
              console.error(`‚ùå Attempt ${attempt} error:`, error);
              if (attempt === retries) {
                  throw error;
              }
              // Wait before retry
              await new Promise(resolve => setTimeout(resolve, 1000));
          }
      }
  }

  // Function to call exec_planner endpoint
  async function callExecPlanner(currentResults, headless = true) {
      try {
          console.log("üì§ Calling exec_planner with results:", currentResults);
          
          const resp = await fetch("/exec_planner", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                  current_results: currentResults,
                  headless: headless
              }),
              timeout: 120000 // 2 minute timeout for planner execution
          });

          if (!resp.ok) {
              const errorInfo = await getDetailedErrorInfo(resp, "Execute Planner");
              console.error("Exec planner error details:", errorInfo);
              throw new Error(formatErrorForUser(errorInfo));
          }

          const result = await resp.json();
          console.log("üì• Exec planner result:", result);
          
          return result;
      } catch (error) {
          console.error("‚ùå callExecPlanner error:", error);
          throw error;
      }
  }

  // Function to call exec_planner_stream endpoint and display output in LLM Reasoning panel
  async function callExecPlannerStream(currentResults, headless = true) {
      try {
          console.log("üì§ Calling exec_planner_stream with results:", currentResults);
          
          // Clear the LLM Reasoning panel
          llmConsole.innerHTML = "";
          
          const resp = await fetch("/exec_planner_stream", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                  current_results: currentResults,
                  headless: headless
              })
          });

          if (!resp.ok) {
              const errorInfo = await getDetailedErrorInfo(resp, "Execute Planner Stream");
              console.error("Exec planner stream error details:", errorInfo);
              throw new Error(formatErrorForUser(errorInfo));
          }

          const reader = resp.body.getReader();
          const decoder = new TextDecoder();
          let plannerOutput = "";
          let plannerCompleted = false;
          let plannerSuccess = false;

          while (true) {
              const { done, value } = await reader.read();
              if (done) break;

              const chunk = decoder.decode(value, { stream: true });
              const lines = chunk.split('\n');

              for (const line of lines) {
                  if (!line.trim()) continue;

                  if (line.startsWith("data: ")) {
                      let content = line.slice(6).trim();

                      if (content === "[DONE]") {
                          plannerCompleted = true;
                          break;
                      }

                      if (content) {
                          // Add the content to the LLM Reasoning panel
                          plannerOutput += content + '\n';
                          llmConsole.innerHTML = plannerOutput;
                          llmConsole.scrollTop = llmConsole.scrollHeight;
                          
                          // Check for success indicators
                          if (content.includes("‚úÖ Robot execution completed successfully")) {
                              plannerSuccess = true;
                              addChatMessage("Max", "ü§ñ Robot execution completed successfully!");
                          } else if (content.includes("‚ùå Robot execution failed")) {
                              addChatMessage("Max", "‚ùå Robot execution failed");
                          } else if (content.includes("Generated action plan:") || content.includes("[STEP 4 RESULT] Final Action Plan:")) {
                              // Extract and display action plan immediately
                              extractActionPlanFromOutput(content);
                          } else if (content.includes("EXECUTING GENERATED PLAN ON ROBOT")) {
                              addChatMessage("Max", "ü§ñ Starting robot execution of the action plan...");
                              // Wait a moment for the action plan to be fully displayed, then start execution indicators
                              setTimeout(() => {
                                  if (window.currentActionPlan && window.currentActionPlan.length > 0) {
                                      addChatMessage("Max", `üöÄ Ready to execute ${window.currentActionPlan.length} actions`);
                                  }
                              }, 1000);
                          } else if (content.includes("4-STEP PIPELINE COMPLETED")) {
                              addChatMessage("Max", "‚úÖ Action plan generation completed!");
                          } else if (content.includes("Max planner completed with success: true")) {
                              addChatMessage("Max", "‚úÖ Max Planner executed successfully!");
                          } else if (content.includes("Max planner completed with success: false")) {
                              addChatMessage("Max", "‚ùå Max Planner failed");
                          }
                          
                          // Check for action execution status updates
                          if (content.includes("Executing action") && content.includes("of")) {
                              // Pattern: "Executing action X of Y"
                              const actionMatch = content.match(/Executing action (\d+) of (\d+)/);
                              if (actionMatch) {
                                  const currentAction = parseInt(actionMatch[1]) - 1; // Convert to 0-based index
                                  const totalActions = parseInt(actionMatch[2]);
                                  
                                  // Mark previous actions as completed
                                  for (let i = 0; i < currentAction; i++) {
                                      updateActionStatus(i, 'completed');
                                  }
                                  // Mark current action
                                  updateActionStatus(currentAction, 'current');
                                  
                                  addChatMessage("Max", `üîÑ Executing step ${currentAction + 1} of ${totalActions}`);
                              }
                          } else if (content.includes("Action completed successfully")) {
                              // Mark current action as completed
                              if (window.currentActionIndex >= 0) {
                                  updateActionStatus(window.currentActionIndex, 'completed');
                                  addChatMessage("Max", `‚úÖ Step ${window.currentActionIndex + 1} completed`);
                              }
                          } else if (content.includes("Robot execution completed successfully")) {
                              // Mark all remaining actions as completed
                              if (window.currentActionPlan && window.currentActionPlan.length > 0) {
                                  for (let i = 0; i < window.currentActionPlan.length; i++) {
                                      updateActionStatus(i, 'completed');
                                  }
                              }
                          }
                      }
                  }
              }

              if (plannerCompleted) break;
          }

          console.log("üì• Exec planner stream completed");
          
      } catch (error) {
          console.error("‚ùå callExecPlannerStream error:", error);
          llmConsole.innerHTML += `\nERROR: ${error.message}`;
          throw error;
      }
  }

  /****************************************************
   * ACTION PLAN VISUALIZATION
   ****************************************************/
  
  // Action to icon mapping
  const actionIconMap = {
    'pick': 'PickupObject.png',
    'pickup': 'PickupObject.png',
    'place': 'PutDownObject.png',
    'put': 'PutDownObject.png',
    'putdown': 'PutDownObject.png',
    'move': 'MovetoObject.png',
    'moveto': 'MovetoObject.png',
    'home': 'Home.png',
    'open': 'OpenGripper.png',
    'close': 'CloseGripper.png'
  };

  // Global variable to store current action plan
  window.currentActionPlan = [];
  window.currentActionIndex = -1;

  function parseActionPlan(planText) {
    console.log("üîç Parsing action plan:", planText);
    
    // Look for action plan patterns like: (Object, (x, y, z), action) -> (Object, (x, y, z), action)
    // Also handle patterns without arrows: (Object, (x, y, z), action)
    const actionRegex = /\(([^,]+),\s*\(([^)]+)\),\s*([^)]+)\)/g;
    const actions = [];
    let match;
    
    while ((match = actionRegex.exec(planText)) !== null) {
      const object = match[1].trim();
      const coordinates = match[2].trim();
      const action = match[3].trim().toLowerCase();
      
      console.log(`üîç Found action: object="${object}", coords="${coordinates}", action="${action}"`);
      
      // Parse coordinates
      const coordParts = coordinates.split(',').map(c => parseInt(c.trim()));
      
      actions.push({
        object: object,
        coordinates: {
          x: coordParts[0] || 0,
          y: coordParts[1] || 0,
          z: coordParts[2] || 0
        },
        action: action,
        status: 'pending' // pending, current, completed
      });
    }
    
    console.log("üìã Parsed actions:", actions);
    return actions;
  }

  function displayActionPlan(actions) {
    const container = document.getElementById('actionPlanContainer');
    const placeholder = document.getElementById('actionPlanPlaceholder');
    
    if (!actions || actions.length === 0) {
      placeholder.style.display = 'block';
      container.innerHTML = '<div id="actionPlanPlaceholder" style="color:#666; font-style:italic; font-size:1em;">Action plan will appear here</div>';
      return;
    }
    
    placeholder.style.display = 'none';
    container.innerHTML = '';
    
    // Create container for sequential display
    const sequenceContainer = document.createElement('div');
    sequenceContainer.className = 'action-sequence';
    sequenceContainer.style.cssText = 'display: flex; align-items: center; justify-content: center; flex-wrap: wrap; gap: 8px;';
    container.appendChild(sequenceContainer);
    
    window.currentActionPlan = actions;
    
    // Display actions one by one with arrows
    displayActionsSequentially(actions, sequenceContainer);
    
    console.log("‚úÖ Action plan will display sequentially with", actions.length, "steps");
  }

  function displayActionsSequentially(actions, container) {
    let currentIndex = 0;
    
    function showNextAction() {
      if (currentIndex >= actions.length) {
        console.log("‚úÖ All action steps displayed");
        return;
      }
      
      const action = actions[currentIndex];
      
      // Add arrow before action (except for first action)
      if (currentIndex > 0) {
        const arrow = document.createElement('div');
        arrow.className = 'action-arrow';
        arrow.innerHTML = '‚Üí';
        arrow.style.cssText = `
          color: #4af;
          font-size: 1.5em;
          font-weight: bold;
          margin: 0 4px;
          opacity: 0;
          transform: scale(0.5);
          transition: all 0.3s ease;
        `;
        container.appendChild(arrow);
        
        // Animate arrow appearance
        setTimeout(() => {
          arrow.style.opacity = '1';
          arrow.style.transform = 'scale(1)';
        }, 100);
      }
      
      // Create action step
      const stepDiv = document.createElement('div');
      stepDiv.className = `action-step ${action.status}`;
      stepDiv.id = `action-step-${currentIndex}`;
      
      // Get the appropriate icon
      const iconFile = actionIconMap[action.action] || 'MovetoObject.png';
      
      stepDiv.innerHTML = `
        <img src="/icons/${iconFile}" alt="${action.action}" class="action-icon" title="${action.object} - ${action.action}">
        <div class="action-label">${action.action}</div>
        <div class="action-object" title="${action.object}">${action.object}</div>
        <div class="action-coordinates">(${action.coordinates.x}, ${action.coordinates.y}, ${action.coordinates.z})</div>
      `;
      
      // Initially hide the step
      stepDiv.style.cssText = `
        opacity: 0;
        transform: scale(0.5) translateY(20px);
        transition: all 0.5s ease;
      `;
      
      container.appendChild(stepDiv);
      
      // Animate step appearance
      setTimeout(() => {
        stepDiv.style.opacity = '1';
        stepDiv.style.transform = 'scale(1) translateY(0)';
      }, 200);
      
      currentIndex++;
      
      // Show next action after delay
      setTimeout(showNextAction, 800);
    }
    
    // Start the sequence
    showNextAction();
  }

  function updateActionStatus(index, status) {
    if (index >= 0 && index < window.currentActionPlan.length) {
      window.currentActionPlan[index].status = status;
      const stepElement = document.getElementById(`action-step-${index}`);
      if (stepElement) {
        stepElement.className = `action-step ${status}`;
      }
      
      // Update current action index
      if (status === 'current') {
        window.currentActionIndex = index;
      } else if (status === 'completed' && window.currentActionIndex === index) {
        window.currentActionIndex = -1;
      }
    }
  }

  function clearActionPlan() {
    const container = document.getElementById('actionPlanContainer');
    
    container.innerHTML = '<div id="actionPlanPlaceholder" style="color:#666; font-style:italic; font-size:1em;">Action plan will appear here</div>';
    window.currentActionPlan = [];
    window.currentActionIndex = -1;
    
    console.log("üßπ Action plan cleared");
  }

  // Function to extract and display action plan from planner output
  function extractActionPlanFromOutput(output) {
    // Look for different patterns of action plan output
    let planText = null;
    
    // Pattern 1: "Generated action plan: plan: ..."
    let planMatch = output.match(/Generated action plan:\s*plan:\s*(.+)/i);
    if (planMatch) {
      planText = planMatch[1];
    } else {
      // Pattern 2: "Generated action plan: ..."
      planMatch = output.match(/Generated action plan:\s*(.+)/i);
      if (planMatch) {
        planText = planMatch[1];
      } else {
        // Pattern 3: "[STEP 4 RESULT] Final Action Plan: plan: ..."
        planMatch = output.match(/\[STEP 4 RESULT\] Final Action Plan:\s*plan:\s*(.+)/i);
        if (planMatch) {
          planText = planMatch[1];
        } else {
          // Pattern 4: "[STEP 4 RESULT] Final Action Plan: ..."
          planMatch = output.match(/\[STEP 4 RESULT\] Final Action Plan:\s*(.+)/i);
          if (planMatch) {
            planText = planMatch[1];
          }
        }
      }
    }
    
    if (planText) {
      console.log("üéØ Found action plan in output:", planText);
      
      const actions = parseActionPlan(planText);
      if (actions.length > 0) {
        displayActionPlan(actions);
        addChatMessage("Max", `üìã Action Plan: ${actions.length} steps will display sequentially`);
        return true;
      }
    }
    return false;
  }

  // Test function for action plan visualization (can be called from browser console)
  window.testActionPlan = function() {
    const testPlan = "(Banana, (-24, -189, 585), move) -> (Banana, (-24, -189, 585), pick) -> (Table, (100, 200, 300), place)";
    console.log("üß™ Testing action plan with:", testPlan);
    const actions = parseActionPlan(testPlan);
    
    // Clear any existing plan first
    clearActionPlan();
    
    // Simulate the planning phase
    addChatMessage("Max", "üß† Generating action plan...");
    
    setTimeout(() => {
      // Display the plan (this simulates when the plan is generated)
      displayActionPlan(actions);
      addChatMessage("Max", "üìã Action Plan: 3 steps will display sequentially");
      
      // Calculate when all icons will be displayed
      const totalDisplayTime = actions.length * 800 + 1000;
      
      setTimeout(() => {
        addChatMessage("Max", "‚úÖ Action plan generation completed!");
        addChatMessage("Max", "ü§ñ Starting robot execution of the action plan...");
        
        setTimeout(() => {
          addChatMessage("Max", "üöÄ Ready to execute 3 actions");
          
          // Start execution simulation
          setTimeout(() => {
            updateActionStatus(0, 'current');
            addChatMessage("Max", "üîÑ Executing step 1 of 3");
          }, 1000);
          
          setTimeout(() => {
            updateActionStatus(0, 'completed');
            updateActionStatus(1, 'current');
            addChatMessage("Max", "‚úÖ Step 1 completed");
            addChatMessage("Max", "üîÑ Executing step 2 of 3");
          }, 3000);
          
          setTimeout(() => {
            updateActionStatus(1, 'completed');
            updateActionStatus(2, 'current');
            addChatMessage("Max", "‚úÖ Step 2 completed");
            addChatMessage("Max", "üîÑ Executing step 3 of 3");
          }, 5000);
          
          setTimeout(() => {
            updateActionStatus(2, 'completed');
            addChatMessage("Max", "‚úÖ Step 3 completed");
            addChatMessage("Max", "üéâ All steps completed successfully!");
          }, 7000);
          
        }, 1000);
      }, totalDisplayTime);
      
    }, 1000);
  };

  /****************************************************
   * EVENT LISTENERS FOR CHAT
   ****************************************************/
  chatSendBtn.addEventListener("click", () => sendChatStream());
  chatInput.addEventListener("keyup", e => { if (e.key === "Enter") sendChatStream(); });
</script>

</body>
</html>