<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>AAU Robot Dashboard</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Overall Grid: 2 rows, 2 columns */
    #dashboard {
      display: grid;
      grid-template-rows: 50% 50%;
      grid-template-columns: 50% 50%;
      width: 100vw;
      height: 100vh;
      min-width: 1920px;
      min-height: 1080px;
      box-sizing: border-box;
      overflow: hidden;
    }
    .panel {
      border: 1px solid #444;
      background: #2a2a2a;
      position: relative;
      display: flex;
      flex-direction: column;
      padding: 8px;
      box-sizing: border-box;
    }
    .panel-title {
      position: absolute;
      top: 8px;
      left: 8px;
      font-weight: bold;
      color: #fff;
      z-index: 2;
    }
    /* For video/image in each window */
    .media-container {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      position: relative;
    }
    /* Ensure video/image fills the container width and scales */
    .media-content {
      width: 100%; /* Fill the full width of the container */
      height: 100%; /* Fill the full height of the container */
      object-fit: contain; /* Maintain aspect ratio while fitting within container */
      display: block;
    }
    #llmConsole {
      font-size: 2em;          /* twice the original size */
      line-height: 1.4;
      white-space: pre-wrap;   /* keep spaces & wrap long lines */
      word-break: break-word;
      color: #4af;             /* Blue for LLM Reasoning */
    }
    .console-area {
      background: #111;
      border: 1px solid #4af;
      font-family: monospace;
      padding: 4px;
      overflow-y: auto;
      flex: 1;
    }
    .neon-btn {
      background-color: #222;
      color: #4af;
      border: 1px solid #4af;
      transition: all 0.2s ease-in-out;
    }
    .neon-btn:hover {
      background-color: #4af;
      color: #111;
      box-shadow: 0 0 8px #4af;
    }
    select {
      background-color: #2a2a2a;
      color: #4af;
      border: 1px solid #4af;
      padding: 4px;
    }
    /* Chat messages font size - reduced to 40% of 4em = 1.6em */
    #chatMessages {
      font-size: 1.6em;        /* 40% of what I made it (was 4em, now 1.6em) */
      line-height: 1.4;
      overflow-y: auto;
      background: #111;
      border: 1px solid #666;
      padding: 8px;
      margin-top: 8px;
    }
    /* Default message styling - all text white */
    #chatMessages div {
      color: #ffffff; /* White for all message content */
      margin-bottom: 0.5em;
    }
    /* Max's name only in blue */
    #chatMessages div[data-sender="Max"] strong {
      color: #4af; /* Blue for Max's name only */
    }
    /* User's name only in green */
    #chatMessages div[data-sender="You"] strong {
      color: #90ee90; /* Green for User's name only */
    }
    /* Instructions area styling - 50% larger */
    .instructions-area {
      height: 30%; /* Increased from 20% to 30% */
      margin-top: 30px; 
      background: #0a0a0a; 
      border: 1px solid #4af; 
      padding: 12px; /* Increased from 8px */
      border-radius: 4px; 
      overflow-y: auto;
      font-size: 1.35em; /* 50% larger (was effectively 1em, now 1.35em) */
    }
    .instructions-title {
      color: #4af; 
      font-weight: bold; 
      margin-bottom: 6px; /* Increased from 4px */
      font-size: 1.1em; /* Slightly larger title */
    }
    .instructions-content {
      line-height: 1.4; /* Increased from 1.3 */
      color: #ccc;
    }
    /* Chat input area styling - larger message box */
    #chatInput {
      font-size: 1.5em; /* Larger input text */
      padding: 8px; /* More padding */
    }
    .chat-send-btn {
      font-size: 1.2em; /* Larger button text */
      padding: 8px 16px; /* More padding */
    }

    /* Robot Control Button Styles */
    .robot-btn {
      padding: 10px 20px;
      border: 2px solid;
      border-radius: 5px;
      font-size: 1.1em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      min-width: 150px;
    }

    .robot-btn-red {
      background-color: #dc3545;
      border-color: #dc3545;
      color: white;
    }

    .robot-btn-yellow {
      background-color: #ffc107;
      border-color: #ffc107;
      color: #212529;
    }

    .robot-btn-green {
      background-color: #28a745;
      border-color: #28a745;
      color: white;
    }

    .robot-btn-gray {
      background-color: #6c757d;
      border-color: #6c757d;
      color: white;
    }

    .robot-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .movement-btn {
      padding: 8px 16px;
      border: 2px solid #4af;
      border-radius: 5px;
      background-color: #222;
      color: #4af;
      font-size: 1em;
      cursor: pointer;
      transition: all 0.3s ease;
      min-width: 80px;
    }

    .movement-btn:hover:not(:disabled) {
      background-color: #4af;
      color: #222;
    }

    .movement-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
      border-color: #666;
      color: #666;
    }

    .movement-btn-active {
      background-color: #ffc107 !important;
      border-color: #ffc107 !important;
      color: #212529 !important;
    }
  </style>
</head>
<body class="bg-gray-900 text-green-300">

<div id="dashboard">
  <!-- Row1, Col1: Camera Outputs (Segmentation and Depth side by side) -->
  <div class="panel" style="grid-row:1; grid-column:1; display:flex; flex-direction:row; padding:0;">
    <!-- Segmentation Output -->
    <div id="segContainer" class="media-container" style="flex:1; border-right:1px solid #333;">
      <div class="panel-title">Segmentation</div>
      <video id="segVideo" class="media-content" autoplay muted playsinline></video>
      <img id="segImg" class="media-content" src="https://via.placeholder.com/320x180?text=Seg" alt="SegOutput" style="display:none;">
    </div>
    <!-- Depth Output -->
    <div id="depthContainer" class="media-container" style="flex:1;">
      <div class="panel-title">Depth</div>
      <img id="depthImg" class="media-content" src="https://via.placeholder.com/320x180?text=Depth" alt="DepthOutput">
      <select id="depthMode" style="position:absolute; top:8px; right:8px; z-index:5;"></select>
    </div>
  </div>

  <!-- Row1, Col2: Robot Control -->
  <div class="panel" style="grid-row:1; grid-column:2;">
    <div class="panel-title">Robot Control</div>
    
    <!-- Robot Status Section -->
    <div style="margin-top:2rem; text-align:center;">
      <button id="robotInitBtn" class="robot-btn robot-btn-red" onclick="initializeRobot()">
        Initialize Robot
      </button>
      <div id="robotStatus" style="margin-top:0.5rem; font-size:1em; color:#ccc;">
        Robot not initialized
      </div>
    </div>
    
    <!-- Movement Controls -->
    <div style="margin-top:2rem;">
      <div style="text-align:center; margin-bottom:1rem;">
        <button id="moveUpBtn" class="movement-btn" onclick="moveRobot('up')" disabled>
          ‚Üë Up
        </button>
      </div>
      
      <div style="display:flex; justify-content:center; gap:1rem; margin-bottom:1rem;">
        <button id="moveLeftBtn" class="movement-btn" onclick="moveRobot('left')" disabled>
          ‚Üê Left
        </button>
        <button id="moveRightBtn" class="movement-btn" onclick="moveRobot('right')" disabled>
          ‚Üí Right
        </button>
      </div>
      
      <div style="text-align:center; margin-bottom:1rem;">
        <button id="moveDownBtn" class="movement-btn" onclick="moveRobot('down')" disabled>
          ‚Üì Down
        </button>
      </div>
      
      <div style="display:flex; justify-content:center; gap:1rem;">
        <button id="moveForwardBtn" class="movement-btn" onclick="moveRobot('forward')" disabled>
          ‚Üó Forward
        </button>
        <button id="moveBackBtn" class="movement-btn" onclick="moveRobot('back')" disabled>
          ‚Üô Back
        </button>
      </div>
    </div>
    
    <!-- Stop Button -->
    <div style="text-align:center; margin-top:2rem;">
      <button id="robotStopBtn" class="robot-btn robot-btn-gray" onclick="stopRobot()" disabled>
        Stop Robot
      </button>
    </div>
  </div>

  <!-- Row2, Col1: Chat -->
  <div class="panel" style="grid-row:2; grid-column:1;">
    <div class="panel-title">Chat</div>
    <!-- Welcome/Instructions Area (larger) -->
    <div class="instructions-area">
      <div class="instructions-title">ü§ñ AAU Robot Assistant</div>
      <div class="instructions-content">
        <strong>Welcome!</strong> I can help you with:<br>
        ‚Ä¢ <strong>Pick objects:</strong> "Pick the red cup on the left"<br>
        ‚Ä¢ <strong>Place objects:</strong> "Place it in the dishwasher"<br>
        ‚Ä¢ <strong>Multi-step:</strong> "Pick the cup and place it on the table"<br>
        ‚Ä¢ <strong>Chat & ask questions</strong> about what I can see<br>
        <em style="color:#4af;">üí° Tip: Be specific about objects and locations!</em>
      </div>
    </div>
    <!-- Chat Messages Area (remaining space) -->
    <div id="chatMessages" style="flex:1; height:calc(70% - 60px);"></div>
    <div style="margin-top:8px; display:flex;">
      <input type="text" id="chatInput" class="bg-gray-800 text-green-300 border border-green-500 px-2 py-1 flex-1" placeholder="Type command...">
      <button id="chatSendBtn" class="neon-btn chat-send-btn" style="margin-left:8px;">Send</button>
    </div>
  </div>

  <!-- Row2, Col2: LLM Reasoning -->
  <div class="panel" style="grid-row:2; grid-column:2; display:flex; flex-direction:column;">
    <div class="panel-title">LLM Reasoning</div>
    <div id="llmConsole" class="console-area" style="margin-top:30px;"></div>
  </div>
</div>

<script>
  /****************************************************
   * ELEMENT REFS
   ****************************************************/
  const segVideo     = document.getElementById("segVideo");
  const segImg       = document.getElementById("segImg");
  const segContainer = document.getElementById("segContainer");
  const depthMode    = document.getElementById("depthMode");
  const depthImg     = document.getElementById("depthImg");
  const chatMessages = document.getElementById("chatMessages");
  const chatInput    = document.getElementById("chatInput");
  const chatSendBtn  = document.getElementById("chatSendBtn");
  const llmConsole   = document.getElementById("llmConsole");

  /****************************************************
   * ENHANCED ERROR HANDLING UTILITIES
   ****************************************************/
  async function getDetailedErrorInfo(response, operation) {
    const errorInfo = {
      operation: operation,
      status: response?.status || 'Unknown',
      statusText: response?.statusText || 'Unknown',
      url: response?.url || 'Unknown',
      type: response?.type || 'Unknown',
      headers: {},
      body: null
    };

    try {
      // Get headers
      if (response?.headers) {
        for (let [key, value] of response.headers.entries()) {
          errorInfo.headers[key] = value;
        }
      }
      
      // Try to get response body
      if (response && !response.bodyUsed) {
        try {
          errorInfo.body = await response.text();
        } catch (e) {
          errorInfo.body = `Could not read response body: ${e.message}`;
        }
      }
    } catch (e) {
      errorInfo.extractionError = e.message;
    }

    return errorInfo;
  }

  function logDetailedError(error, operation, response = null) {
    console.error(`‚ùå DETAILED ERROR for ${operation}:`, {
      errorMessage: error.message,
      errorType: error.constructor.name,
      stack: error.stack,
      response: response,
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      url: window.location.href
    });
  }

  function formatErrorForUser(errorInfo) {
    let message = `[${errorInfo.operation}] `;
    
    if (errorInfo.status === 'Unknown') {
      message += `Connection failed - unable to reach server. `;
      message += `URL: ${errorInfo.url}`;
    } else {
      message += `HTTP ${errorInfo.status} ${errorInfo.statusText}. `;
      if (errorInfo.body && errorInfo.body.length < 200) {
        message += `Response: ${errorInfo.body}`;
      } else if (errorInfo.body) {
        message += `Response: ${errorInfo.body.substring(0, 200)}...`;
      }
    }
    
    return message;
  }

  /****************************************************
   * STATE
   ****************************************************/
  let segFrozen          = false;
  let isSegmenting       = false;
  let realsenseSegTimer  = null;
  let depthTimer         = null;
  let realsenseAvailable = false;
  let robotStatusTimer   = null;

  /****************************************************
   * ROBOT CONTROL FUNCTIONS
   ****************************************************/

  // Start monitoring robot status
  function startRobotStatusMonitoring() {
    if (robotStatusTimer) return;
    
    robotStatusTimer = setInterval(async () => {
      try {
        const resp = await fetch("/robot/status");
        if (resp.ok) {
          const status = await resp.json();
          updateRobotUI(status);
        }
      } catch (e) {
        console.error("Robot status check failed:", e);
      }
    }, 1000); // Check every second
  }

  // Stop monitoring robot status  
  function stopRobotStatusMonitoring() {
    if (robotStatusTimer) {
      clearInterval(robotStatusTimer);
      robotStatusTimer = null;
    }
  }

  // Update robot UI based on status
  function updateRobotUI(status) {
    const initBtn = document.getElementById("robotInitBtn");
    const statusDiv = document.getElementById("robotStatus");
    const stopBtn = document.getElementById("robotStopBtn");
    
    // Update status message
    statusDiv.textContent = status.message;
    
    // Update init button
    initBtn.className = "robot-btn ";
    switch (status.state) {
      case "disconnected":
        initBtn.className += "robot-btn-red";
        initBtn.textContent = "Initialize Robot";
        initBtn.disabled = false;
        stopBtn.disabled = true;
        break;
      case "initializing":
        initBtn.className += "robot-btn-yellow";
        initBtn.textContent = "Initializing...";
        initBtn.disabled = true;
        stopBtn.disabled = false;
        break;
      case "ready":
        initBtn.className += "robot-btn-green";
        initBtn.textContent = "Robot Ready";
        initBtn.disabled = true;
        stopBtn.disabled = false;
        break;
      case "moving":
        initBtn.className += "robot-btn-green";
        initBtn.textContent = "Robot Ready";
        initBtn.disabled = true;
        stopBtn.disabled = false;
        break;
      case "error":
        initBtn.className += "robot-btn-red";
        initBtn.textContent = "Error - Retry";
        initBtn.disabled = false;
        stopBtn.disabled = false;
        break;
    }
    
    // Update movement buttons
    const movementButtons = [
      "moveUpBtn", "moveDownBtn", "moveLeftBtn", 
      "moveRightBtn", "moveForwardBtn", "moveBackBtn"
    ];
    
    movementButtons.forEach(btnId => {
      const btn = document.getElementById(btnId);
      if (btn) {
        btn.disabled = !status.buttons_enabled || status.state === "moving";
        
        // Remove active state if not moving
        if (status.state !== "moving") {
          btn.classList.remove("movement-btn-active");
        }
      }
    });
  }

  // Initialize robot
  async function initializeRobot() {
    try {
      addChatMessage("Max", "Starting robot initialization...");
      
      const resp = await fetch("/robot/initialize", { method: "POST" });
      if (resp.ok) {
        console.log("Robot initialization started");
      } else {
        const error = await resp.json();
        addChatMessage("Max", `Robot initialization failed: ${error.error}`);
      }
    } catch (e) {
      console.error("Robot initialization error:", e);
      addChatMessage("Max", `Robot initialization error: ${e.message}`);
    }
  }

  // Move robot in specified direction
  async function moveRobot(direction) {
    try {
      // Set button to active state
      const btnId = `move${direction.charAt(0).toUpperCase() + direction.slice(1)}Btn`;
      const btn = document.getElementById(btnId);
      if (btn) {
        btn.classList.add("movement-btn-active");
      }
      
      const resp = await fetch(`/robot/move/${direction}`, { method: "POST" });
      if (resp.ok) {
        console.log(`Robot moving ${direction}`);
        addChatMessage("Max", `Moving robot ${direction} (2cm)`);
      } else {
        const error = await resp.json();
        addChatMessage("Max", `Robot movement failed: ${error.error}`);
        // Remove active state on error
        if (btn) {
          btn.classList.remove("movement-btn-active");
        }
      }
    } catch (e) {
      console.error("Robot movement error:", e);
      addChatMessage("Max", `Robot movement error: ${e.message}`);
    }
  }

  // Stop robot
  async function stopRobot() {
    try {
      const resp = await fetch("/robot/stop", { method: "POST" });
      if (resp.ok) {
        addChatMessage("Max", "Robot stopped and disconnected");
      } else {
        const error = await resp.json();
        addChatMessage("Max", `Robot stop failed: ${error.error}`);
      }
    } catch (e) {
      console.error("Robot stop error:", e);
      addChatMessage("Max", `Robot stop error: ${e.message}`);
    }
  }

  /****************************************************
   * PAGE LOAD
   ****************************************************/
  window.addEventListener("DOMContentLoaded", async () => {
    // Start robot monitoring
    startRobotStatusMonitoring();

    // Fetch camera info to check RealSense availability
    try {
      const res = await fetch("/camera_info");
      const info = await res.json();
      realsenseAvailable = info.realsense_available;
      console.log("RealSense available:", realsenseAvailable);
    } catch (e) {
      realsenseAvailable = false;
      console.error("Error checking camera info:", e);
      logDetailedError(e, "Camera Info Check");
      addChatMessage("Max", "Error checking RealSense availability. Functionality may be limited.");
    }

    updateDepthDropdown();

    // Automatically start RealSense for segmentation if available
    if (realsenseAvailable) {
      startRealSenseSeg();
      // Start depth processing with default option
      depthMode.value = "realsense_rgb_anything";
      depthTimer = setInterval(() => processDepth(depthMode.value), 500);
    } else {
      addChatMessage("Max", "RealSense not detected. Segmentation and Depth will be inactive.");
    }
  });

  /****************************************************
   * SEGMENTATION - RealSense Only
   ****************************************************/
  function startRealSenseSeg() {
    segVideo.style.display = "none";
    segImg.style.display = "block";
    realsenseSegTimer = setInterval(fetchRealsenseSeg, 250);
    console.log("Starting RealSense for segmentation.");
  }

  async function fetchRealsenseSeg() {
    try {
      const resp = await fetch("/process_realsense_seg", { method: "POST" });
      if (!resp.ok) {
        const errorInfo = await getDetailedErrorInfo(resp, "RealSense Segmentation");
        console.error("RealSense fetch error details:", errorInfo);
        throw new Error(`Failed to fetch RealSense frame: ${resp.status} ${resp.statusText}`);
      }
      const d = await resp.json();
      if (d.frame) segImg.src = "data:image/jpeg;base64," + d.frame;
    } catch (e) {
      console.error("RealSense fetch error:", e);
      logDetailedError(e, "RealSense Segmentation");
    }
  }

  // Freeze the Seg window ‚Äî no more frames will arrive until we unfreeze
  function freezeSegWindow(base64Frame) {
      segFrozen = true;
      isSegmenting = false; // Ensure it's not marked as segmenting to allow future clicks
      if (realsenseSegTimer) {
          clearInterval(realsenseSegTimer);
          realsenseSegTimer = null;
          console.log("Cleared RealSense timer to prevent frame updates. Timer ID: null");
      }

      // Swap to frozen JPEG
      segImg.src = "data:image/jpeg;base64," + base64Frame;
      segVideo.style.display = "none";
      segImg.style.display = "block";
      console.log("Segmentation window frozen with captured frame. State: segFrozen=" + segFrozen + ", isSegmenting=" + isSegmenting + ", Timer: " + (realsenseSegTimer ? "Active" : "Cleared"));
  }

  // Unfreeze & resume RealSense feed
  function unfreezeSegWindow() {
      segFrozen = false;
      fetch("/reset_seg", { method: "POST" }).catch(e => {
        console.error("Reset seg error:", e);
        logDetailedError(e, "Reset Segmentation");
      });

      if (realsenseAvailable && !realsenseSegTimer) {
          realsenseSegTimer = setInterval(fetchRealsenseSeg, 250);
          console.log("Started RealSense timer for frame updates. Timer ID: " + realsenseSegTimer);
      }
      console.log("Segmentation window unfrozen. State: segFrozen=" + segFrozen + ", isSegmenting=" + isSegmenting + ", Timer: " + (realsenseSegTimer ? "Active" : "Not Started"));
  }

segContainer.addEventListener("click", async ev => {
    if (!realsenseAvailable) return;

    // FIRST CLICK: freeze and segment
    if (!segFrozen) {
        try {
            isSegmenting = true;
            console.log("First click: Capturing frame for segmentation. State before: segFrozen=" + segFrozen + ", isSegmenting=" + isSegmenting);
            const frameB64 = await captureSegFrame();
            freezeSegWindow(frameB64);

            // Get the image element and its bounding rectangle in the browser
            const imgElement = segImg.style.display !== "none" ? segImg : segVideo;
            const rr = imgElement.getBoundingClientRect();

            // Get the natural dimensions of the image (original size)
            const naturalWidth = imgElement.naturalWidth || imgElement.videoWidth || 640; // Fallback to expected width if unknown
            const naturalHeight = imgElement.naturalHeight || imgElement.videoHeight || 480; // Fallback to expected height if unknown

            // Compute the displayed dimensions and aspect ratio
            const displayedWidth = rr.width;
            const displayedHeight = rr.height;
            const aspectRatio = naturalWidth / naturalHeight;

            // Calculate the actual content area within the container (due to object-fit: contain)
            let contentWidth, contentHeight, offsetX, offsetY;
            if (displayedWidth / displayedHeight > aspectRatio) {
                // Image is constrained by height, black bars on sides
                contentHeight = displayedHeight;
                contentWidth = displayedHeight * aspectRatio;
                offsetX = (displayedWidth - contentWidth) / 2;
                offsetY = 0;
            } else {
                // Image is constrained by width, black bars on top/bottom
                contentWidth = displayedWidth;
                contentHeight = displayedWidth / aspectRatio;
                offsetY = (displayedHeight - contentHeight) / 2;
                offsetX = 0;
            }

            // Compute click position relative to the content area
            const clickX = ev.clientX - rr.left - offsetX;
            const clickY = ev.clientY - rr.top - offsetY;

            // Normalize click coordinates to the natural image dimensions
            const nx = (clickX / contentWidth) * naturalWidth;
            const ny = (clickY / contentHeight) * naturalHeight;

            // Ensure coordinates are within bounds
            const clampedNx = Math.max(0, Math.min(naturalWidth, nx)) / naturalWidth;
            const clampedNy = Math.max(0, Math.min(naturalHeight, ny)) / naturalHeight;

            console.log(`Click at normalized coords: (${clampedNx.toFixed(3)}, ${clampedNy.toFixed(3)}) based on natural size ${naturalWidth}x${naturalHeight}`);

            const resp = await fetch("/process_seg", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ frame: frameB64, clicked_x: clampedNx, clicked_y: clampedNy })
            });
            if (resp.ok) {
                const dd = await resp.json();
                if (dd.object_info) {
                    addChatMessage(
                        "Max",
                        `Center: ${dd.object_info.center_xyz_mm.map(v => Math.round(v)).join(', ')} mm; ` +
                        `distance ${dd.object_info.distance_m.toFixed(3)} m; ` +
                        `Size ${Math.round(dd.object_info.length_mm)}√ó${Math.round(dd.object_info.width_mm)} mm; ` +
                        `Orientation ${Math.round(dd.object_info.orientation_deg)}¬∞`
                    );
                }
                // Update overlay on frozen image - this now includes the verified circle
                segImg.src = "data:image/jpeg;base64," + dd.frame;
                console.log("Updated image with segmentation results and verified center point.");
            
            } else {
                const errorInfo = await getDetailedErrorInfo(resp, "Process Segmentation");
                console.error("Segmentation processing error:", errorInfo);
                addChatMessage("Max", `Segmentation error: ${formatErrorForUser(errorInfo)}`);
            }
        } catch (e) {
            console.error("Seg error:", e);
            logDetailedError(e, "Segmentation Click");
            addChatMessage("Max", `Segmentation error: ${e.message}`);
        } finally {
            isSegmenting = false;
            console.log("Segmentation complete. Final state: segFrozen=" + segFrozen + ", isSegmenting=" + isSegmenting);
        }
    }
    // SECOND CLICK: unfreeze
    else {
        unfreezeSegWindow();
    }
});

  /****************************************************
   * DEPTH
   ****************************************************/
  function updateDepthDropdown() {
    if (realsenseAvailable) {
      depthMode.innerHTML = `
        <option value="realsense_rgb_anything">RealSense RGB + Depth Anything</option>
        <option value="realsense_depth">RealSense Depth</option>
      `;
    } else {
      depthMode.innerHTML = `
        <option value="unavailable">Unavailable</option>
      `;
      depthMode.disabled = true;
      addChatMessage("Max", "RealSense not available. Depth options are disabled.");
    }
  }

  depthMode.addEventListener("change", () => {
    clearInterval(depthTimer);
    depthImg.src = "https://via.placeholder.com/320x180?text=Depth";
    const v = depthMode.value;
    if (realsenseAvailable && v !== "unavailable") {
      depthTimer = setInterval(() => processDepth(v), 500);
    }
  });

  async function processDepth(mode) {
    try {
      const r = await fetch("/process_depth", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ camera_mode: mode, local_idx: 0, frame: "" })
      });
      
      if (!r.ok) {
        const errorInfo = await getDetailedErrorInfo(r, "Depth Processing");
        console.error("Depth processing error:", errorInfo);
        return;
      }
      
      const d = await r.json();
      if (d.frame) depthImg.src = "data:image/jpeg;base64," + d.frame;
    } catch (e) {
      console.error("Depth processing error:", e);
      logDetailedError(e, "Depth Processing");
    }
  }

  /****************************************************
   * FRAME CAPTURE UTILS
   ****************************************************/
  function captureSegFrame() {
    return new Promise((res, rej) => {
      if (realsenseAvailable) {
        const p = segImg.src.split(",");
        p[1] ? res(p[1]) : rej("No RealSense frame");
      } else {
        rej("RealSense not available");
      }
    });
  }

  /****************************************************
   * CHAT
   ****************************************************/
  function addChatMessage(sender, msg) {
    if (chatMessages.children.length > 2000) chatMessages.removeChild(chatMessages.firstChild);
    const dv = document.createElement("div");
    dv.setAttribute("data-sender", sender); // Add data attribute for styling
    dv.innerHTML = `<strong>${sender}:</strong> ${msg}`;
    chatMessages.appendChild(dv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
  }

  async function sendChatStream(customText) {
      const userText = (customText || chatInput.value).trim();
      if (!userText) return;

      // Store current user message for results
      window.current_user_message = userText;
      // Don't set a fake path here - let the server provide the real one

      chatInput.value = "";
      addChatMessage("You", userText);

      // Clear reasoning window
      llmConsole.innerHTML = "";

      // Unfreeze segmentation window and reset state to ensure fresh frames
      unfreezeSegWindow();

      try {
          console.log("üîç Attempting streaming request...");
          const success = await tryStreamingChat(userText);

          if (!success) {
              console.log("üîÑ Streaming failed, trying non-streaming fallback...");
              await tryFallbackChat(userText);
          }
      } catch (error) {
          console.error("‚ùå Chat error:", error);
          logDetailedError(error, "Chat Stream");
          addChatMessage("Max", `Error: ${error.message}. Please try again.`);
      }
  }

  async function tryStreamingChat(userText) {
      try {
          console.log("üì§ Attempting fetch to /chat-stream");
          const resp = await fetch("/chat-stream", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ text: userText })
          });

          if (!resp.ok) {
              console.log(`‚ùå Streaming response not ok: ${resp.status}`);
              const errorInfo = await getDetailedErrorInfo(resp, "Chat Stream");
              console.error("Streaming error details:", errorInfo);
              addChatMessage("Max", `Chat streaming failed: ${formatErrorForUser(errorInfo)}`);
              return false;
          }

          const reader = resp.body.getReader();
          const decoder = new TextDecoder();
          let reasoning = "";
          let answer = "";
          let actionBuffer = "";

          while (true) {
              const { done, value } = await reader.read();
              if (done) break;

              const chunk = decoder.decode(value, { stream: true });
              const lines = chunk.split('\n');

              for (const line of lines) {
                  if (!line.trim()) continue;

                  if (line.startsWith("data: ")) {
                      let content = line.slice(6).trim();

                      if (content === "[DONE]") break;
                      // Handle thinking and response content
                      if (content.startsWith("thinking:")) {
                          const thinkingToken = content.slice(9);
                          // Add space if needed before appending token
                          if (reasoning && thinkingToken && needsSpace(reasoning, thinkingToken)) {
                              reasoning += " " + thinkingToken;
                          } else {
                              reasoning += thinkingToken;
                          }
                          llmConsole.innerHTML = reasoning;
                          llmConsole.scrollTop = llmConsole.scrollHeight;
                      } else if (content.startsWith("response:")) {
                          const responseToken = content.slice(9);
                          // PRESERVE newlines in action buffer
                          if (answer && responseToken && needsSpace(answer, responseToken)) {
                              answer += " " + responseToken;
                          } else {
                              answer += responseToken;
                          }
                          // For action buffer, preserve the raw token to maintain formatting
                          actionBuffer += responseToken;
                      } else {
                          // PRESERVE newlines in action buffer
                          if (answer && content && needsSpace(answer, content)) {
                              answer += " " + content;
                          } else {
                              answer += content;
                          }
                          // For action buffer, preserve the raw token to maintain formatting
                          actionBuffer += content;
                      }

                      // Check for [ACTION] in the accumulated buffer
                      if (actionBuffer.includes("[ACTION]")) {
                          console.log("‚úÖ [ACTION] block detected in streaming!");
                          const actionResult = extractAndProcessAction(actionBuffer);
                          if (actionResult.processed) {
                              actionBuffer = actionResult.remainingBuffer;
                              return true; // Exit early since action is being handled
                          }
                      }
                  }
              }
          }

          // After streaming, if no action was processed, show the response
          if (answer.trim() && !answer.includes("[ACTION]")) {
              console.log("‚úÖ No action detected, showing regular chat response.");
              addChatMessage("Max", answer.trim());
              return true;
          }

          // Final attempt to process action if present
          if (actionBuffer.includes("[ACTION]")) {
              console.log("‚úÖ [ACTION] detected at stream end, final processing attempt.");
              const actionResult = extractAndProcessAction(actionBuffer);
              if (actionResult.processed) {
                  return true;
              }
          }

          console.log("‚ùå No valid response or action processed.");
          return false;
      } catch (error) {
          console.error("‚ùå Streaming error:", error);
          logDetailedError(error, "Chat Stream Request");
          addChatMessage("Max", `Streaming error: ${error.message}`);
          return false;
      }
  }

  // Helper function to determine if a space is needed between two text fragments
  function needsSpace(existingText, newToken) {
      // If either string is empty, no space is needed
      if (!existingText || !newToken) return false;

      // Get the last character of existing text and first character of new token
      const lastChar = existingText.slice(-1);
      const firstChar = newToken[0];

      // If the last character is a space or punctuation, no additional space is needed
      if (/\s|[.,!?;]/.test(lastChar)) return false;

      // If the first character is a space or punctuation, no additional space is needed
      if (/\s|[.,!?;]/.test(firstChar)) return false;

      // If both characters are alphanumeric, a space is likely needed
      if (/[a-zA-Z0-9]/.test(lastChar) && /[a-zA-Z0-9]/.test(firstChar)) return true;

      // Default: no space needed (e.g., connecting symbols or mixed cases)
      return false;
  }

  function extractAndProcessAction(buffer) {
    const actionIndex = buffer.indexOf("[ACTION]");
    if (actionIndex === -1) {
      return { processed: false, remainingBuffer: buffer };
    }

    // Extract content after [ACTION]
    const actionContent = buffer.slice(actionIndex).trim();
    console.log("üîç Extracted [ACTION] content:", actionContent);

    // Split into lines for parsing
    const lines = actionContent.split('\n').filter(line => line.trim());
    console.log("üîç Lines in [ACTION] block:", lines);

    // If fewer than 2 lines, wait for more content
    if (lines.length < 2) {
      console.log("üîç Partial [ACTION] block, waiting for more content.");
      return { processed: false, remainingBuffer: buffer };
    }

    // Find the required lines - more flexible matching
    let roboPointLine = null;
    let actionLine = null;

    for (const line of lines) {
        // More flexible regex that handles "[ACTION]RoboPoint Request:" format
        if (!roboPointLine && /RoboPoint\s*Request\s*:/i.test(line)) {
            roboPointLine = line;
            console.log("‚úÖ Found RoboPoint line:", line);
        } else if (!actionLine && /Action\s*Request\s*:/i.test(line)) {
            actionLine = line;
            console.log("‚úÖ Found Action line:", line);
        }
    }

    // Better handling of combined lines
    if (!roboPointLine || !actionLine) {
        // Try to split a single combined line
        for (const line of lines) {
            if (line.includes("RoboPoint Request:") && line.includes("Action Request:")) {
                const parts = line.split(/Action\s*Request\s*:/i);
                if (parts.length === 2) {
                    roboPointLine = parts[0].trim();
                    actionLine = "Action Request:" + parts[1].trim();
                    console.log("‚úÖ Split combined line:", { roboPointLine, actionLine });
                    break;
                }
            }
        }
    }
    
    if (!actionLine) {
      for (const line of lines) {
        if (line.toLowerCase().includes("action") || line.toLowerCase().includes("pick") || line.toLowerCase().includes("place")) {
          actionLine = line;
          console.log("‚úÖ Found Action line (keyword match):", line);
          break;
        }
      }
    }

    // If still not found, report error but log full content for debugging
    if (!roboPointLine) {
      console.log("‚ùå Could not find RoboPoint Request line in:", lines);
      addChatMessage("Max", `Error: Missing 'RoboPoint Request:' line. Full response logged for debugging.`);
      addChatMessage("Max", `Debug content: ${actionContent.length > 200 ? actionContent.substring(0, 200) + '...' : actionContent}`);
      return { processed: false, remainingBuffer: buffer };
    }

    if (!actionLine) {
      console.log("‚ùå Could not find Action Request line in:", lines);
      addChatMessage("Max", `Error: Missing 'Action Request:' line. Full response logged for debugging.`);
      addChatMessage("Max", `Debug content: ${actionContent.length > 200 ? actionContent.substring(0, 200) + '...' : actionContent}`);
      return { processed: false, remainingBuffer: buffer };
    }

    // Process the action
    console.log("‚úÖ Complete [ACTION] block found, processing...");
    addChatMessage("Max", "ü§ñ Processing action request... Searching for objects.");
    executeMultiStepActions(actionContent);

    const remainingBuffer = buffer.slice(actionIndex + actionContent.length).trim();
    return { processed: true, remainingBuffer };
  }

  async function tryFallbackChat(userText) {
    try {
      addChatMessage("Max", "Processing your request...");
      console.log("üì§ Attempting fetch to /chat");
      const resp = await fetch("/chat", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ text: userText })
      });

      if (!resp.ok) {
        const errorInfo = await getDetailedErrorInfo(resp, "Chat Fallback");
        console.error("Fallback error details:", errorInfo);
        throw new Error(`Server error: ${formatErrorForUser(errorInfo)}`);
      }

      const data = await resp.json();
      console.log("üîç Fallback response:", data);

      const response = data.reply || data.answer || "";
      if (response) {
        if (response.includes("[ACTION]")) {
          console.log("‚úÖ [ACTION] detected in fallback response, processing...");
          addChatMessage("Max", "ü§ñ Processing action request... Searching for objects.");
          await executeMultiStepActions(response);
        } else {
          console.log("‚úÖ No action in fallback, showing regular response.");
          addChatMessage("Max", response);
        }
      } else {
        addChatMessage("Max", "No response received from fallback.");
      }
    } catch (error) {
      console.error("‚ùå Fallback error:", error);
      logDetailedError(error, "Chat Fallback");
      addChatMessage("Max", `Fallback error: ${error.message}`);
    }
  }

  async function executeMultiStepActions(actionBlock) {
      console.log("üîç DEBUG: Raw action block:", actionBlock);

      // Clear previous results
      window.robopoint_results = [];
      window.current_results = {
          user_message: window.current_user_message || "Unknown command",
          imagePath: "Unknown path",  // Will be updated with actual path
          objects: []
      };

    try {
        // Extract [ACTION] block content
        const actionMatch = actionBlock.match(/\[ACTION\]\s*([\s\S]*?)(?:\n\n|$)/i);
        if (!actionMatch) {
            throw new Error("Could not find [ACTION] block in response");
        }

        const content = actionMatch[1].trim();
        console.log("üîç DEBUG: Action content:", content);

        // Split into lines, handle single line with both requests
        let lines = content.split('\n').map(line => line.trim()).filter(line => line);
        if (lines.length === 1 && lines[0].includes("Action Request:")) {
            const idx = lines[0].indexOf("Action Request:");
            lines = [
                lines[0].slice(0, idx).trim(),
                lines[0].slice(idx).trim()
            ];
        }
        console.log("üîç DEBUG: All lines:", lines);

        let roboPointLine = null;
        let actionLines = [];  // ‚úÖ Changed to array to collect multiple action lines

        for (const line of lines) {
            if (line.match(/^\s*RoboPoint\s+Request\s*:/i)) {
                roboPointLine = line;
                console.log("‚úÖ Found RoboPoint line:", line);
            } else if (line.match(/^\s*Action\s+Request\s*:/i)) {
                actionLines.push(line);  // ‚úÖ Collect all action lines
                console.log("‚úÖ Found Action line:", line);
            }
        }

        // Detailed error reporting
        if (!roboPointLine) {
            console.log("‚ùå Available lines:", lines);
            addChatMessage("Max", `Error: Missing 'RoboPoint Request:' line.`);
            return;
        }

        if (actionLines.length === 0) {  // ‚úÖ Check if we have any action lines
            console.log("‚ùå Available lines:", lines);
            addChatMessage("Max", `Error: Missing 'Action Request:' line.`);
            return;
        }

        // Extract content after colons
        const roboPointContent = roboPointLine.split(':', 2)[1];

        // ‚úÖ Combine all action lines and parse them
        let allActionContent = "";
        if (actionLines.length === 1) {
            // Single line: might be "Pick; Place" or just "Pick"
            allActionContent = actionLines[0].split(':', 2)[1];
        } else {
            // Multiple lines: combine them with semicolons
            const actionParts = actionLines.map(line => line.split(':', 2)[1].trim());
            allActionContent = actionParts.join('; ');
        }

        if (!roboPointContent || !allActionContent) {
            addChatMessage("Max", "Error: Could not extract content from request/action lines");
            return;
        }

        // Parse the semicolon-separated values
        const objects = roboPointContent.split(';').map(s => s.trim()).filter(s => s);
        const actions = allActionContent.split(';').map(s => s.trim()).filter(s => s);

        console.log("üîç DEBUG: Parsed objects:", objects);
        console.log("üîç DEBUG: Parsed actions:", actions);

        if (objects.length !== actions.length) {
            addChatMessage("Max", `Error: Mismatch between objects (${objects.length}) and actions (${actions.length}).`);
            return;
        }

        if (objects.length === 0) {
            addChatMessage("Max", "Error: No valid commands found in the action block");
            return;
        }

        // Success - start processing
        addChatMessage("Max", `‚úÖ Found ${objects.length} command(s). Starting execution...`);

        // Unfreeze segmentation window to ensure fresh frames for RoboPoint actions
        unfreezeSegWindow();

        // Wait briefly to ensure a fresh frame is fetched
        await new Promise(resolve => setTimeout(resolve, 300));

        // Capture frame
        let frameB64 = "";
        try {
            frameB64 = await captureSegFrame();
            freezeSegWindow(frameB64);
        } catch (e) {
            console.warn("No seg frame:", e);
            addChatMessage("Max", "Warning: Could not capture frame. Continuing anyway...");
        }

        // Execute each command
for (let i = 0; i < objects.length; i++) {
            const object = objects[i];
            const action = actions[i];

            addChatMessage("Max", `üîÑ Step ${i+1}: Finding "${object}"...`);

            try {
                const result = await executeRoboPointCommand(object, action, frameB64);

                // Update image path with the actual saved path from the first result
                if (i === 0 && result.image_path) {
                    window.current_results.imagePath = result.image_path;
                    console.log(`üìÅ Updated image path: ${result.image_path}`);
                }

                if (result.seg_frame) {
                    segImg.src = "data:image/jpeg;base64," + result.seg_frame;
                    console.log("Updated image with RoboPoint results. State after: segFrozen=" + segFrozen + ", isSegmenting=" + isSegmenting);
                }

                // Collect result in the desired format
                if (result.object_info && result.object_info.center_xyz_mm) {
                    const info = result.object_info;
                    const objectResult = {
                        action: action.toLowerCase(),
                        location: result.placement || "unknown",
                        object: object,
                        object_center_location: {
                            x: Math.round(info.center_xyz_mm[0]),
                            y: Math.round(info.center_xyz_mm[1]),
                            z: Math.round(info.center_xyz_mm[2])
                        },
                        object_size: {
                            width: Math.round(info.width_mm),
                            length: Math.round(info.length_mm)
                        },
                        object_orientation: Math.round(info.orientation_deg)
                    };
                    
                    window.current_results.objects.push(objectResult);
                    
                    addChatMessage("Max", 
                        `‚úÖ Step ${i+1}: Successfully found "${object}"! Location: ${info.center_xyz_mm.map(v=>Math.round(v)).join(', ')} mm, Distance: ${info.distance_m.toFixed(3)} m, Size: ${Math.round(info.length_mm)}√ó${Math.round(info.width_mm)} mm, Orientation: ${Math.round(info.orientation_deg)}¬∞`
                    );
                } else {
                    // Add result even without detailed info
                    const objectResult = {
                        action: action.toLowerCase(),
                        location: result.placement || "unknown",
                        object: object,
                        object_center_location: { x: 0, y: 0, z: 0 },
                        object_size: { width: 0, length: 0 },
                        object_orientation: 0
                    };
                    window.current_results.objects.push(objectResult);
                    addChatMessage("Max", `‚úÖ Step ${i+1}: Successfully found "${object}"`);
                }

                // Pause between steps
                if (i < objects.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 800));
                }
            } catch (error) {
                console.error(`‚ùå Step ${i+1} failed:`, error);
                addChatMessage("Max", `‚ùå Step ${i+1} Failed: ${error.message}`);
                break;
            }
        }

        // Print final results to console
        console.log("ü§ñ ROBOPOINT RESULTS:");
        console.log("=".repeat(50));
        console.log(JSON.stringify(window.current_results, null, 2));
        console.log("=".repeat(50));

        addChatMessage("Max", `üéâ Completed ${objects.length} action(s)!`);
        
        // Keep the segmentation window frozen to show results
        console.log("Keeping segmentation window frozen to show results. Click or send a new message to unfreeze. State: segFrozen=" + segFrozen + ", isSegmenting=" + isSegmenting + ", Timer: " + (realsenseSegTimer ? "Active" : "Cleared"));
    } catch (error) {
        console.error("‚ùå Action parsing error:", error);
        logDetailedError(error, "Action Parsing");
        addChatMessage("Max", `Action parsing error: ${error.message}`);
        unfreezeSegWindow();
    }
}

  async function executeRoboPointCommand(objectDescription, action, frameB64, retries = 2) {
      const singleActionBlock = `[ACTION]\nRoboPoint Request: ${objectDescription}\nAction Request: ${action}`;
      
      for (let attempt = 1; attempt <= retries; attempt++) {
          console.log(`üì§ Attempt ${attempt}: Sending to RoboPoint:`, singleActionBlock);
          
          try {
              const resp = await fetch("/exec_action", {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                      action_block: singleActionBlock,
                      seg_frame: frameB64
                  }),
                  timeout: 90000 // 90 second timeout
              });

              if (!resp.ok) {
                  const errorInfo = await getDetailedErrorInfo(resp, "Execute RoboPoint Command");
                  console.error(`Attempt ${attempt} failed:`, errorInfo);
                  if (attempt === retries) {
                      throw new Error(formatErrorForUser(errorInfo));
                  }
                  continue;
              }

              const result = await resp.json();
              console.log("üì• RoboPoint result:", result);
              
              if (result.error) {
                  throw new Error(`RoboPoint server error: ${result.error}`);
              }
              
              return result;
          } catch (error) {
              console.error(`‚ùå Attempt ${attempt} error:`, error);
              if (attempt === retries) {
                  throw error;
              }
              // Wait before retry
              await new Promise(resolve => setTimeout(resolve, 1000));
          }
      }
  }

  /****************************************************
   * EVENT LISTENERS FOR CHAT
   ****************************************************/
  chatSendBtn.addEventListener("click", () => sendChatStream());
  chatInput.addEventListener("keyup", e => { if (e.key === "Enter") sendChatStream(); });
</script>

</body>
</html>