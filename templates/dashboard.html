<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>AAU Robot Dashboard</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Overall Grid: 2 rows, 2 columns - Responsive */
    #dashboard {
      display: grid;
      grid-template-rows: 50% 50%;
      grid-template-columns: 50% 50%;
      width: 100vw;
      height: 100vh;
      min-width: 320px;  /* Mobile minimum */
      min-height: 480px; /* Mobile minimum */
      box-sizing: border-box;
      overflow: hidden;
    }
    
    /* Responsive breakpoints */
    @media (max-width: 1200px) {
      #dashboard {
        grid-template-rows: 1fr 1fr;
        grid-template-columns: 1fr 1fr;
      }
    }
    
    @media (max-width: 768px) {
      #dashboard {
        grid-template-rows: 1fr 1fr 1fr 1fr;
        grid-template-columns: 1fr;
      }
      
      /* Stack panels vertically on mobile */
      .panel:nth-child(1) { grid-row: 1; grid-column: 1; }
      .panel:nth-child(2) { grid-row: 2; grid-column: 1; }
      .panel:nth-child(3) { grid-row: 3; grid-column: 1; }
      .panel:nth-child(4) { grid-row: 4; grid-column: 1; }
      
      /* Adjust camera panel layout for mobile */
      .panel[style*="flex-direction:row"] {
        flex-direction: column !important;
      }
      
      /* Adjust robot control layout for mobile */
      .panel[style*="grid-row:1"][style*="grid-column:2"] > div[style*="height:50%"] {
        height: auto !important;
      }
    }
    
    /* Ultra small screens */
    @media (max-width: 480px) {
      body {
        font-size: 12px;
      }
      
      .panel-title {
        font-size: 0.8rem !important;
      }
      
      /* Hide some less critical elements on very small screens */
      .instructions-area {
        display: none;
      }
    }
    .panel {
      border: 1px solid #444;
      background: #2a2a2a;
      position: relative;
      display: flex;
      flex-direction: column;
      padding: 8px;
      box-sizing: border-box;
    }
    
    /* Responsive panel adjustments */
    @media (max-width: 768px) {
      .panel {
        padding: 4px;
        min-height: 200px;
      }
    }
    .panel-title {
      position: absolute;
      top: 8px;
      left: 8px;
      font-weight: bold;
      color: #fff;
      z-index: 2;
      font-size: 1rem;
    }
    
    /* Responsive panel title */
    @media (max-width: 768px) {
      .panel-title {
        font-size: 0.9rem;
        top: 4px;
        left: 4px;
      }
    }
    /* For video/image in each window */
    .media-container {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      position: relative;
    }
    /* Ensure video/image fills the container width and scales */
    .media-content {
      width: 100%; /* Fill the full width of the container */
      height: 100%; /* Fill the full height of the container */
      object-fit: contain; /* Maintain aspect ratio while fitting within container */
      display: block;
    }
    
    /* Responsive media content */
    @media (max-width: 768px) {
      .media-content {
        object-fit: cover; /* Better fit for small screens */
      }
    }
    #llmConsole {
      font-size: 1.2em;          /* Reduced from 2em to 1.2em */
      line-height: 1.5;          /* Increased for better readability */
      white-space: pre-wrap;      /* keep spaces & wrap long lines */
      word-break: break-word;
      color: #4af;                /* Blue for LLM Reasoning */
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace; /* Better monospace font */
    }
    
    /* Responsive LLM Console */
    @media (max-width: 1200px) {
      #llmConsole {
        font-size: 1.1em;
      }
    }
    
    @media (max-width: 768px) {
      #llmConsole {
        font-size: 1em;
      }
    }
    
    @media (max-width: 480px) {
      #llmConsole {
        font-size: 0.9em;
      }
    }
    .console-area {
      background: #111;
      border: 1px solid #4af;
      font-family: monospace;
      padding: 4px;
      overflow-y: auto;
      flex: 1;
    }
    .neon-btn {
      background-color: #222;
      color: #4af;
      border: 1px solid #4af;
      transition: all 0.2s ease-in-out;
    }
    .neon-btn:hover {
      background-color: #4af;
      color: #111;
      box-shadow: 0 0 8px #4af;
    }
    select {
      background-color: #2a2a2a;
      color: #4af;
      border: 1px solid #4af;
      padding: 4px;
    }
    /* Chat messages font size - reduced for better readability */
    #chatMessages {
      font-size: 1.1em;        /* Reduced from 1.6em to 1.1em */
      line-height: 1.4;
      overflow-y: auto;
      background: #111;
      border: 1px solid #666;
      padding: 8px;
      margin-top: 8px;
    }
    
    /* Responsive Chat Messages */
    @media (max-width: 1200px) {
      #chatMessages {
        font-size: 1em;
        padding: 6px;
      }
    }
    
    @media (max-width: 768px) {
      #chatMessages {
        font-size: 0.95em;
        padding: 4px;
        margin-top: 4px;
      }
    }
    
    @media (max-width: 480px) {
      #chatMessages {
        font-size: 0.85em;
      }
    }
    /* Default message styling - all text white */
    #chatMessages div {
      color: #ffffff; /* White for all message content */
      margin-bottom: 0.5em;
    }
    /* Max's name only in blue */
    #chatMessages div[data-sender="Max"] strong {
      color: #4af; /* Blue for Max's name only */
    }
    /* User's name only in green */
    #chatMessages div[data-sender="You"] strong {
      color: #90ee90; /* Green for User's name only */
    }
    /* Instructions area styling - smaller font size */
    .instructions-area {
      height: 30%; /* Increased from 20% to 30% */
      margin-top: 30px; 
      background: #0a0a0a; 
      border: 1px solid #4af; 
      padding: 12px; /* Increased from 8px */
      border-radius: 4px; 
      overflow-y: auto;
      font-size: 0.9em; /* Reduced from 1.35em to 0.9em for smaller text */
    }
    .instructions-title {
      color: #4af; 
      font-weight: bold; 
      margin-bottom: 6px; /* Increased from 4px */
      font-size: 1.1em; /* Slightly larger title */
    }
    .instructions-content {
      line-height: 1.4; /* Increased from 1.3 */
      color: #ccc;
    }
    /* Chat input area styling - larger message box */
    #chatInput {
      font-size: 1.5em; /* Larger input text */
      padding: 8px; /* More padding */
    }
    .chat-send-btn {
      font-size: 1.2em; /* Larger button text */
      padding: 8px 16px; /* More padding */
    }
    
    /* Responsive Chat Input */
    @media (max-width: 1200px) {
      #chatInput {
        font-size: 1.3em;
        padding: 6px;
      }
      .chat-send-btn {
        font-size: 1.1em;
        padding: 6px 12px;
      }
    }
    
    @media (max-width: 768px) {
      #chatInput {
        font-size: 1.1em;
        padding: 4px;
      }
      .chat-send-btn {
        font-size: 1em;
        padding: 4px 8px;
      }
    }
    
    @media (max-width: 480px) {
      #chatInput {
        font-size: 1em;
        padding: 3px;
      }
      .chat-send-btn {
        font-size: 0.9em;
        padding: 3px 6px;
      }
    }

    /* Robot Control Button Styles */
    .robot-btn {
      padding: 6px 12px;
      border: 2px solid;
      border-radius: 5px;
      font-size: 0.9em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      min-width: 100px;
    }
    
    /* Responsive Robot Buttons */
    @media (max-width: 1200px) {
      .robot-btn {
        font-size: 0.8em;
        padding: 5px 10px;
        min-width: 80px;
      }
    }
    
    @media (max-width: 768px) {
      .robot-btn {
        font-size: 0.7em;
        padding: 4px 8px;
        min-width: 60px;
      }
    }
    
    @media (max-width: 480px) {
      .robot-btn {
        font-size: 0.6em;
        padding: 3px 6px;
        min-width: 50px;
      }
    }

    .robot-btn-red {
      background-color: #dc3545;
      border-color: #dc3545;
      color: white;
    }

    .robot-btn-yellow {
      background-color: #ffc107;
      border-color: #ffc107;
      color: #212529;
    }

    .robot-btn-green {
      background-color: #28a745;
      border-color: #28a745;
      color: white;
    }

    .robot-btn-gray {
      background-color: #6c757d;
      border-color: #6c757d;
      color: white;
    }

    .robot-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .movement-btn {
      padding: 4px 8px;
      border: 2px solid #4af;
      border-radius: 3px;
      background-color: #222;
      color: #4af;
      font-size: 0.8em;
      cursor: pointer;
      transition: all 0.3s ease;
      min-width: 60px;
    }
    
    /* Responsive Movement Buttons */
    @media (max-width: 1200px) {
      .movement-btn {
        font-size: 0.7em;
        padding: 3px 6px;
        min-width: 50px;
      }
    }
    
    @media (max-width: 768px) {
      .movement-btn {
        font-size: 0.6em;
        padding: 2px 4px;
        min-width: 40px;
      }
    }
    
    @media (max-width: 480px) {
      .movement-btn {
        font-size: 0.5em;
        padding: 2px 3px;
        min-width: 35px;
      }
    }

    .movement-btn:hover:not(:disabled) {
      background-color: #4af;
      color: #222;
    }

    .movement-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
      border-color: #666;
      color: #666;
    }

    .movement-btn-active {
      background-color: #ffc107 !important;
      border-color: #ffc107 !important;
      color: #212529 !important;
    }

    /* Suction parameter inputs */
    .suction-input {
      width: 50px;
      background: #222;
      color: #4af;
      border: 1px solid #4af;
      padding: 2px;
      text-align: center;
      font-size: 0.7em;
    }

    /* Action Plan Visualization Styles */
    .action-sequence {
      display: flex;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      gap: 8px;
      padding: 4px;
    }
    
    .action-step {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 4px;
      padding: 6px;
      background: #222;
      border: 1px solid #4af;
      border-radius: 6px;
      min-width: 80px;
      transition: all 0.5s ease;
    }
    
    .action-arrow {
      color: #4af;
      font-size: 1.5em;
      font-weight: bold;
      margin: 0 4px;
      text-shadow: 0 0 4px #4af;
      animation: arrowGlow 2s ease-in-out infinite alternate;
    }
    
    @keyframes arrowGlow {
      from { text-shadow: 0 0 4px #4af; }
      to { text-shadow: 0 0 8px #4af, 0 0 12px #4af; }
    }
    
    .action-step:hover {
      background: #333;
      border-color: #6cf;
      transform: scale(1.05);
    }
    
    .action-step.completed {
      border-color: #28a745;
      background: #1a3d1a;
    }
    
    .action-step.current {
      border-color: #ffc107;
      background: #3d3d1a;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0.7); }
      70% { box-shadow: 0 0 0 10px rgba(255, 193, 7, 0); }
      100% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0); }
    }
    
    .action-icon {
      width: 32px;
      height: 32px;
      margin-bottom: 4px;
      filter: brightness(0.8);
    }
    
    .action-step:hover .action-icon {
      filter: brightness(1.2);
    }
    
    .action-step.completed .action-icon {
      filter: brightness(1) hue-rotate(120deg);
    }
    
    .action-step.current .action-icon {
      filter: brightness(1.3) hue-rotate(45deg);
    }
    
    .action-label {
      font-size: 0.7em;
      color: #ccc;
      text-align: center;
      font-weight: bold;
      text-transform: uppercase;
    }
    
    .action-object {
      font-size: 0.6em;
      color: #888;
      text-align: center;
      margin-top: 2px;
      max-width: 70px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .action-coordinates {
      font-size: 0.5em;
      color: #666;
      text-align: center;
      margin-top: 1px;
      font-family: monospace;
    }
    
    /* Responsive Action Plan */
    @media (max-width: 1200px) {
      .action-step {
        min-width: 70px;
        padding: 4px;
      }
      .action-icon {
        width: 28px;
        height: 28px;
      }
      .action-label {
        font-size: 0.65em;
      }
      .action-object {
        font-size: 0.55em;
        max-width: 60px;
      }
      .action-arrow {
        font-size: 1.3em;
        margin: 0 3px;
      }
    }
    
    @media (max-width: 768px) {
      .action-sequence {
        gap: 4px;
      }
      .action-step {
        min-width: 60px;
        padding: 3px;
      }
      .action-icon {
        width: 24px;
        height: 24px;
      }
      .action-label {
        font-size: 0.6em;
      }
      .action-object {
        font-size: 0.5em;
        max-width: 50px;
      }
      .action-coordinates {
        display: none; /* Hide coordinates on mobile */
      }
      .action-arrow {
        font-size: 1.1em;
        margin: 0 2px;
      }
    }
    
    @media (max-width: 480px) {
      #actionPlanContainer {
        gap: 4px;
      }
      .action-sequence {
        gap: 2px;
        flex-direction: column; /* Stack vertically on very small screens */
        align-items: center;
      }
      .action-step {
        min-width: 50px;
        padding: 2px;
      }
      .action-icon {
        width: 20px;
        height: 20px;
      }
      .action-label {
        font-size: 0.55em;
      }
      .action-object {
        font-size: 0.45em;
        max-width: 45px;
      }
      .action-arrow {
        font-size: 1em;
        margin: 2px 0;
        transform: rotate(90deg); /* Vertical arrows for vertical layout */
      }
    }

    /* Responsive Instructions Area */
    @media (max-width: 1200px) {
      .instructions-area {
        font-size: 0.85em;
      }
      .instructions-title {
        font-size: 1em;
      }
    }
    
    @media (max-width: 768px) {
      .instructions-area {
        font-size: 0.8em;
        padding: 8px;
        margin-top: 20px;
      }
      .instructions-title {
        font-size: 0.95em;
      }
    }
    
    @media (max-width: 480px) {
      .instructions-area {
        font-size: 0.75em;
        padding: 6px;
        margin-top: 15px;
      }
      .instructions-title {
        font-size: 0.9em;
      }
    }
  </style>
</head>
<body class="bg-gray-900 text-green-300">

<div id="dashboard">
  <!-- Row1, Col1: Camera Outputs (Segmentation and Depth side by side) -->
  <div class="panel" style="grid-row:1; grid-column:1; display:flex; flex-direction:row; padding:0;">
    <!-- Segmentation Output -->
    <div id="segContainer" class="media-container" style="flex:1; border-right:1px solid #333;">
      <div class="panel-title">Segmentation</div>
      <video id="segVideo" class="media-content" autoplay muted playsinline></video>
      <img id="segImg" class="media-content" src="https://via.placeholder.com/320x180?text=Seg" alt="SegOutput" style="display:none;">
    </div>
    <!-- Depth Output -->
    <div id="depthContainer" class="media-container" style="flex:1;">
      <div class="panel-title">Depth</div>
      <img id="depthImg" class="media-content" src="https://via.placeholder.com/320x180?text=Depth" alt="DepthOutput">
      <select id="depthMode" style="position:absolute; top:8px; right:8px; z-index:5;"></select>
    </div>
  </div>

  <!-- Row1, Col2: Robot Control (Top 50% only) + Empty Space (50%) -->
  <div class="panel" style="grid-row:1; grid-column:2; display:flex; flex-direction:column; padding:8px;">
    <div class="panel-title">Robot Control</div>
    
    <!-- Top 50%: Robot Controls -->
    <div style="height:50%; border-bottom:1px solid #444; padding-bottom:8px; margin-bottom:8px; display:flex;">
      <!-- Left 80%: All Controls -->
      <div style="width:80%; display:flex; flex-direction:column; padding-right:8px;">
        
      <!-- Row 1: Robot Status Section -->
      <div style="display:flex; gap:8px; align-items:center; justify-content:center; margin-bottom:6px;">
        <button id="robotInitBtn" class="robot-btn robot-btn-red" onclick="initializeRobot(true)">
          Initialize (Headless)
        </button>
        <button id="robotInteractiveBtn" class="robot-btn robot-btn-red" onclick="initializeRobot(false)">
          Initialize (Interactive)
        </button>
      </div>
      <div style="text-align:center; margin-bottom:6px;">
        <div id="robotStatus" style="font-size:0.8em; color:#ccc;">Robot not initialized</div>
        <div style="font-size:0.7em; color:#888; margin-top:2px;">
          <strong>Headless:</strong> Dashboard controls only (1920x1080)<br>
          <strong>Interactive:</strong> Browser window + Dashboard controls
        </div>
      </div>
        
        <!-- Row 2: Distance Input and Movement Controls -->
        <div style="display:flex; gap:8px; align-items:center; justify-content:center; margin-bottom:6px;">
          <!-- Distance Input -->
          <div style="display:flex; align-items:center; gap:4px;">
            <label style="color:#4af; font-size:0.8em;">Distance:</label>
            <input type="number" id="moveDistance" value="20" min="1" max="500" 
                  style="width:50px; background:#222; color:#4af; border:1px solid #4af; padding:2px; text-align:center; font-size:0.8em;">
            <span style="color:#4af; font-size:0.8em;">mm</span>
          </div>
          
          <!-- Movement Controls Grid -->
          <div style="display:grid; grid-template-columns:1fr 1fr 1fr; grid-template-rows:1fr 1fr 1fr; gap:2px; width:120px;">
            <div></div>
            <button id="moveUpBtn" class="movement-btn" onclick="moveRobot('up')" disabled style="font-size:0.7em;">↑</button>
            <div></div>
            
            <button id="moveLeftBtn" class="movement-btn" onclick="moveRobot('left')" disabled style="font-size:0.7em;">←</button>
            <div></div>
            <button id="moveRightBtn" class="movement-btn" onclick="moveRobot('right')" disabled style="font-size:0.7em;">→</button>
            
            <div></div>
            <button id="moveDownBtn" class="movement-btn" onclick="moveRobot('down')" disabled style="font-size:0.7em;">↓</button>
            <div></div>
          </div>
        </div>
        
        <!-- Row 3: Action Buttons -->
        <div style="display:flex; gap:4px; justify-content:center; margin-bottom:6px;">
          <button id="moveForwardBtn" class="movement-btn" onclick="moveRobot('forward')" disabled style="font-size:0.7em;">↗ Forward</button>
          <button id="moveBackBtn" class="movement-btn" onclick="moveRobot('back')" disabled style="font-size:0.7em;">↙ Back</button>
          <button id="getPositionBtn" class="movement-btn" onclick="getRobotPosition()" disabled style="font-size:0.7em;">Get Pos</button>
          <button id="suctionOnBtn" class="movement-btn" onclick="openSuctionModal()" disabled style="font-size:0.7em;">Suct On</button>
          <button id="suctionOffBtn" class="movement-btn" onclick="suctionOff()" disabled style="font-size:0.7em;">Suct Off</button>
          <button id="homeBtn" class="movement-btn" onclick="moveToHome()" disabled style="font-size:0.7em;">Home</button>
        </div>
        
        <!-- Row 4: Suction Parameters -->
        <div style="display:flex; gap:6px; align-items:center; justify-content:center; margin-bottom:6px;">
          <div style="display:flex; align-items:center; gap:2px;">
            <label style="color:#4af; font-size:0.7em;">Load:</label>
            <input type="number" id="suctionLoad" value="100" min="0" max="2000" class="suction-input">
          </div>
          <div style="display:flex; align-items:center; gap:2px;">
            <label style="color:#4af; font-size:0.7em;">Vacuum:</label>
            <input type="number" id="suctionVacuum" value="650" min="550" max="750" class="suction-input">
          </div>
          <div style="display:flex; align-items:center; gap:2px;">
            <label style="color:#4af; font-size:0.7em;">Timeout:</label>
            <input type="number" id="suctionTimeout" value="5.0" min="0.5" max="10" step="0.1" class="suction-input">
          </div>
        </div>
        
        <!-- Row 5: Stop Button -->
        <div style="text-align:center;">
          <button id="robotStopBtn" class="robot-btn robot-btn-gray" onclick="stopRobot()" disabled style="font-size:0.8em;">
            Stop Robot
          </button>
        </div>
        
      </div>
      
      <!-- Right 20%: Position Display (90% height, centered) -->
      <div style="width:20%; display:flex; align-items:center;">
        <div style="width:100%; height:90%; background:#111; border:1px solid #4af; padding:6px; font-family:monospace; font-size:1.2em; line-height:1.3;">
          <div style="color:#4af; font-weight:bold; margin-bottom:6px; font-size:0.8em; text-align:center;">Robot Position:</div>
          <div id="positionDisplay" style="color:#ccc;">
            <div>X: --- mm</div>
            <div>Y: --- mm</div>
            <div>Z: --- mm</div>
            <div>RX: --- °</div>
            <div>RY: --- °</div>
            <div>RZ: --- °</div>
          </div>
        </div>
      </div>
      
    </div>
    
    <!-- Bottom 50%: Action Plan Visualization -->
    <div id="actionPlanArea" style="height:50%; background:#1a1a1a; border:1px solid #333; border-radius:4px; display:flex; flex-direction:column; padding:8px;">
      <div style="color:#4af; font-weight:bold; font-size:0.9em; margin-bottom:8px; text-align:center;">
        Action Plan Visualization
      </div>
      <div id="actionPlanContainer" style="flex:1; display:flex; flex-wrap:wrap; align-items:center; justify-content:center; gap:8px; overflow-y:auto;">
        <div id="actionPlanPlaceholder" style="color:#666; font-style:italic; font-size:1em;">
          Action plan will appear here
        </div>
      </div>
    </div>
  </div>

  <!-- Row2, Col1: Chat -->
  <div class="panel" style="grid-row:2; grid-column:1;">
    <div class="panel-title">Chat</div>
    <!-- Welcome/Instructions Area (larger) -->
    <div class="instructions-area">
      <div class="instructions-title">🤖 Max Intelligent Robot Assistant</div>
      <div class="instructions-content">
        <strong>Welcome!</strong> I can help you with:<br>
        • <strong>Pick objects:</strong> "Pick the red cup on the left"<br>
        • <strong>Place objects:</strong> "Place it in the dishwasher"<br>
        • <strong>Multi-step:</strong> "Pick the cup and place it on the table"<br>
        • <strong>Chat & ask questions</strong> about what I can see<br>
        <em style="color:#4af;">💡 Tip: Be specific about objects and locations!</em>
      </div>
    </div>
    <!-- Chat Messages Area (remaining space) -->
    <div id="chatMessages" style="flex:1; height:calc(70% - 60px);"></div>
    <div style="margin-top:8px; display:flex;">
      <input type="text" id="chatInput" class="bg-gray-800 text-green-300 border border-green-500 px-2 py-1 flex-1" placeholder="Type command...">
      <button id="chatSendBtn" class="neon-btn chat-send-btn" style="margin-left:8px;">Send</button>
    </div>
  </div>

  <!-- Row2, Col2: LLM Reasoning -->
  <div class="panel" style="grid-row:2; grid-column:2; display:flex; flex-direction:column;">
    <div class="panel-title">LLM Reasoning</div>
    <div id="llmConsole" class="console-area" style="margin-top:30px;"></div>
  </div>
</div>

<script>
  /****************************************************
   * ELEMENT REFS
   ****************************************************/
  const segVideo     = document.getElementById("segVideo");
  const segImg       = document.getElementById("segImg");
  const segContainer = document.getElementById("segContainer");
  const depthMode    = document.getElementById("depthMode");
  const depthImg     = document.getElementById("depthImg");
  const chatMessages = document.getElementById("chatMessages");
  const chatInput    = document.getElementById("chatInput");
  const chatSendBtn  = document.getElementById("chatSendBtn");
  const llmConsole   = document.getElementById("llmConsole");

  /****************************************************
   * ENHANCED ERROR HANDLING UTILITIES
   ****************************************************/
  async function getDetailedErrorInfo(response, operation) {
    const errorInfo = {
      operation: operation,
      status: response?.status || 'Unknown',
      statusText: response?.statusText || 'Unknown',
      url: response?.url || 'Unknown',
      type: response?.type || 'Unknown',
      headers: {},
      body: null
    };

    try {
      // Get headers
      if (response?.headers) {
        for (let [key, value] of response.headers.entries()) {
          errorInfo.headers[key] = value;
        }
      }
      
      // Try to get response body
      if (response && !response.bodyUsed) {
        try {
          errorInfo.body = await response.text();
        } catch (e) {
          errorInfo.body = `Could not read response body: ${e.message}`;
        }
      }
    } catch (e) {
      errorInfo.extractionError = e.message;
    }

    return errorInfo;
  }

  function logDetailedError(error, operation, response = null) {
    console.error(`❌ DETAILED ERROR for ${operation}:`, {
      errorMessage: error.message,
      errorType: error.constructor.name,
      stack: error.stack,
      response: response,
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      url: window.location.href
    });
  }

  function formatErrorForUser(errorInfo) {
    let message = `[${errorInfo.operation}] `;
    
    if (errorInfo.status === 'Unknown') {
      message += `Connection failed - unable to reach server. `;
      message += `URL: ${errorInfo.url}`;
    } else {
      message += `HTTP ${errorInfo.status} ${errorInfo.statusText}. `;
      if (errorInfo.body && errorInfo.body.length < 200) {
        message += `Response: ${errorInfo.body}`;
      } else if (errorInfo.body) {
        message += `Response: ${errorInfo.body.substring(0, 200)}...`;
      }
    }
    
    return message;
  }

  /****************************************************
   * STATE
   ****************************************************/
  let segFrozen          = false;
  let isSegmenting       = false;
  let realsenseSegTimer  = null;
  let depthTimer         = null;
  let realsenseAvailable = false;
  let robotStatusTimer   = null;

  /****************************************************
   * ROBOT CONTROL FUNCTIONS
   ****************************************************/

  // Start monitoring robot status
  function startRobotStatusMonitoring() {
    if (robotStatusTimer) return;
    
    robotStatusTimer = setInterval(async () => {
      try {
        const resp = await fetch("/robot/status");
        if (resp.ok) {
          const status = await resp.json();
          updateRobotUI(status);
        }
      } catch (e) {
        console.error("Robot status check failed:", e);
      }
    }, 1000); // Check every second
  }

  // Stop monitoring robot status  
  function stopRobotStatusMonitoring() {
    if (robotStatusTimer) {
      clearInterval(robotStatusTimer);
      robotStatusTimer = null;
    }
  }

  // Enhanced move robot function with custom distance
  async function moveRobot(direction) {
    try {
      // Get distance from input field
      const distanceInput = document.getElementById("moveDistance");
      const distance = parseInt(distanceInput.value) || 20;
      
      // Validate distance
      if (distance < 1 || distance > 700) {
        addChatMessage("Max", `Invalid distance: ${distance}mm. Must be between 1-700mm.`);
        return;
      }
      
      // Set button to active state
      const btnId = `move${direction.charAt(0).toUpperCase() + direction.slice(1)}Btn`;
      const btn = document.getElementById(btnId);
      if (btn) {
        btn.classList.add("movement-btn-active");
      }
      
      const resp = await fetch(`/robot/move/${direction}`, { 
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ distance: distance })
      });
      
      if (resp.ok) {
        console.log(`Robot moving ${direction} ${distance}mm`);
        addChatMessage("Max", `Moving robot ${direction} (${distance}mm)`);
      } else {
        const error = await resp.json();
        addChatMessage("Max", `Robot movement failed: ${error.error}`);
        // Remove active state on error
        if (btn) {
          btn.classList.remove("movement-btn-active");
        }
      }
    } catch (e) {
      console.error("Robot movement error:", e);
      addChatMessage("Max", `Robot movement error: ${e.message}`);
    }
  }

  // Get robot position function
  async function getRobotPosition() {
    try {
      addChatMessage("Max", "Getting robot position...");
      
      const resp = await fetch("/robot/position", { method: "GET" });
      if (resp.ok) {
        const position = await resp.json();
        updatePositionDisplay(position);
        addChatMessage("Max", "Robot position updated!");
      } else {
        const error = await resp.json();
        addChatMessage("Max", `Get position failed: ${error.error}`);
      }
    } catch (e) {
      console.error("Get position error:", e);
      addChatMessage("Max", `Get position error: ${e.message}`);
    }
  }

  // Update position display
  function updatePositionDisplay(position) {
    const display = document.getElementById("positionDisplay");
    if (position && position.pos_x !== undefined) {
      display.innerHTML = `
        <div>X: ${Math.round(position.pos_x)} mm</div>
        <div>Y: ${Math.round(position.pos_y)} mm</div>
        <div>Z: ${Math.round(position.pos_z)} mm</div>
        <div>RX: ${Math.round(position.rot_x)}°</div>
        <div>RY: ${Math.round(position.rot_y)}°</div>
        <div>RZ: ${Math.round(position.rot_z)}°</div>
      `;
    } else {
      display.innerHTML = `
        <div>X: --- mm</div>
        <div>Y: --- mm</div>
        <div>Z: --- mm</div>
        <div>RX: --- °</div>
        <div>RY: --- °</div>
        <div>RZ: --- °</div>
      `;
    }
  }

  // Open suction modal/parameters and execute
  async function openSuctionModal() {
    try {
      // Get values from inputs
      const load = parseInt(document.getElementById("suctionLoad").value);
      const vacuum = parseInt(document.getElementById("suctionVacuum").value);
      const timeout = parseFloat(document.getElementById("suctionTimeout").value);
      
      addChatMessage("Max", `Turning suction on with Load: ${load}, Vacuum: ${vacuum}, Timeout: ${timeout}s...`);
      
      const resp = await fetch("/robot/suction/on", { 
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ load: load, vacuum: vacuum, timeout: timeout })
      });
      
      if (resp.ok) {
        addChatMessage("Max", "Suction activated successfully!");
      } else {
        const error = await resp.json();
        addChatMessage("Max", `Suction on failed: ${error.error}`);
      }
    } catch (e) {
      console.error("Suction on error:", e);
      addChatMessage("Max", `Suction on error: ${e.message}`);
    }
  }

  // Suction off function
  async function suctionOff() {
    try {
      addChatMessage("Max", "Turning suction off...");
      
      const resp = await fetch("/robot/suction/off", { method: "POST" });
      if (resp.ok) {
        addChatMessage("Max", "Suction deactivated successfully!");
      } else {
        const error = await resp.json();
        addChatMessage("Max", `Suction off failed: ${error.error}`);
      }
    } catch (e) {
      console.error("Suction off error:", e);
      addChatMessage("Max", `Suction off error: ${e.message}`);
    }
  }

  // Move to home function
  async function moveToHome() {
    try {
      addChatMessage("Max", "Moving robot to home position...");
      
      const resp = await fetch("/robot/home", { method: "POST" });
      if (resp.ok) {
        addChatMessage("Max", "Robot moved to home position successfully!");
      } else {
        const error = await resp.json();
        addChatMessage("Max", `Move to home failed: ${error.error}`);
      }
    } catch (e) {
      console.error("Move to home error:", e);
      addChatMessage("Max", `Move to home error: ${e.message}`);
    }
  }

  // Enhanced input validation for all fields
  document.addEventListener("DOMContentLoaded", function() {
    // Distance input validation
    const distanceInput = document.getElementById("moveDistance");
    if (distanceInput) {
      distanceInput.addEventListener("input", function() {
        let value = parseInt(this.value);
        if (isNaN(value) || value < 1) {
          this.value = 1;
        } else if (value > 700) {
          this.value = 700;
        }
      });
      
      distanceInput.addEventListener("blur", function() {
        if (!this.value) {
          this.value = 20; // Default back to 20
        }
      });
    }

    // Suction parameter validation
    const suctionLoad = document.getElementById("suctionLoad");
    if (suctionLoad) {
      suctionLoad.addEventListener("input", function() {
        let value = parseInt(this.value);
        if (isNaN(value) || value < 0) {
          this.value = 0;
        } else if (value > 2000) {
          this.value = 2000;
        }
      });
    }

    const suctionVacuum = document.getElementById("suctionVacuum");
    if (suctionVacuum) {
      suctionVacuum.addEventListener("input", function() {
        let value = parseInt(this.value);
        if (isNaN(value) || value < 550) {
          this.value = 550;
        } else if (value > 750) {
          this.value = 750;
        }
      });
    }

    const suctionTimeout = document.getElementById("suctionTimeout");
    if (suctionTimeout) {
      suctionTimeout.addEventListener("input", function() {
        let value = parseFloat(this.value);
        if (isNaN(value) || value < 0.5) {
          this.value = 0.5;
        } else if (value > 10) {
          this.value = 10;
        }
      });
    }
  });

  // Initialize robot with headless parameter
  async function initializeRobot(headless = true) {
    try {
      const modeText = headless ? "headless" : "interactive";
      addChatMessage("Max", `🤖 Starting robot initialization in ${modeText} mode...`);
      
      const resp = await fetch("/robot/initialize", { 
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ headless: headless })
      });
      
      if (resp.ok) {
        console.log(`Robot ${modeText} initialization started`);
        if (!headless) {
          addChatMessage("Max", "🌐 Browser window should open shortly with Franka Desk interface!");
          addChatMessage("Max", "🎮 Dashboard control buttons will be enabled once ready.");
          addChatMessage("Max", "💡 You can use BOTH the browser interface AND the dashboard buttons!");
        } else {
          addChatMessage("Max", "🤖 Headless mode - 1920x1080 viewport, dashboard controls only");
        }
      } else {
        const error = await resp.json();
        addChatMessage("Max", `Robot initialization failed: ${error.error}`);
      }
    } catch (e) {
      console.error("Robot initialization error:", e);
      addChatMessage("Max", `Robot initialization error: ${e.message}`);
    }
  }

  // Updated robot status function to show mode
  function updateRobotUI(status) {
    const initBtn = document.getElementById("robotInitBtn");
    const interactiveBtn = document.getElementById("robotInteractiveBtn");
    const statusDiv = document.getElementById("robotStatus");
    const stopBtn = document.getElementById("robotStopBtn");
    
    // Update status message
    statusDiv.textContent = status.message;
    
    // Update init buttons
    initBtn.className = "robot-btn ";
    interactiveBtn.className = "robot-btn ";
    
    switch (status.state) {
      case "disconnected":
        initBtn.className += "robot-btn-red";
        initBtn.textContent = "Initialize (Headless)";
        initBtn.disabled = false;
        interactiveBtn.className += "robot-btn-red";
        interactiveBtn.textContent = "Initialize (Interactive)";
        interactiveBtn.disabled = false;
        stopBtn.disabled = true;
        break;
      case "initializing":
        initBtn.className += "robot-btn-yellow";
        initBtn.textContent = "Initializing...";
        initBtn.disabled = true;
        interactiveBtn.className += "robot-btn-yellow";
        interactiveBtn.textContent = "Initializing...";
        interactiveBtn.disabled = true;
        stopBtn.disabled = false;
        break;
      case "ready":
        initBtn.className += "robot-btn-green";
        initBtn.textContent = "Robot Ready";
        initBtn.disabled = true;
        interactiveBtn.className += "robot-btn-green";
        interactiveBtn.textContent = "Robot Ready";
        interactiveBtn.disabled = true;
        stopBtn.disabled = false;
        break;
      case "moving":
        // Keep ready state buttons but show moving status
        initBtn.className += "robot-btn-green";
        initBtn.textContent = "Robot Ready";
        initBtn.disabled = true;
        interactiveBtn.className += "robot-btn-green";
        interactiveBtn.textContent = "Robot Ready";
        interactiveBtn.disabled = true;
        stopBtn.disabled = false;
        break;
      case "error":
        initBtn.className += "robot-btn-red";
        initBtn.textContent = "Error - Retry (H)";
        initBtn.disabled = false;
        interactiveBtn.className += "robot-btn-red";
        interactiveBtn.textContent = "Error - Retry (I)";
        interactiveBtn.disabled = false;
        stopBtn.disabled = false;
        break;
    }
    
    // Update ALL control buttons
    const controlButtons = [
      "moveUpBtn", "moveDownBtn", "moveLeftBtn", "moveRightBtn", 
      "moveForwardBtn", "moveBackBtn", "getPositionBtn", 
      "suctionOnBtn", "suctionOffBtn", "homeBtn"
    ];
    
    controlButtons.forEach(btnId => {
      const btn = document.getElementById(btnId);
      if (btn) {
        btn.disabled = !status.buttons_enabled || status.state === "moving";
        
        // Remove active state if not moving
        if (status.state !== "moving") {
          btn.classList.remove("movement-btn-active");
        }
      }
    });
  }


  // Stop robot
  async function stopRobot() {
    try {
      const resp = await fetch("/robot/stop", { method: "POST" });
      if (resp.ok) {
        addChatMessage("Max", "Robot stopped and disconnected");
      } else {
        const error = await resp.json();
        addChatMessage("Max", `Robot stop failed: ${error.error}`);
      }
    } catch (e) {
      console.error("Robot stop error:", e);
      addChatMessage("Max", `Robot stop error: ${e.message}`);
    }
  }

  /****************************************************
   * PAGE LOAD
   ****************************************************/
  window.addEventListener("DOMContentLoaded", async () => {
      // Start robot monitoring
      startRobotStatusMonitoring();

      // Fetch camera info to check RealSense availability
      try {
        const res = await fetch("/camera_info");
        const info = await res.json();
        realsenseAvailable = info.realsense_available;
        console.log("RealSense available:", realsenseAvailable);
      } catch (e) {
        realsenseAvailable = false;
        console.error("Error checking camera info:", e);
        logDetailedError(e, "Camera Info Check");
        addChatMessage("Max", "Error checking RealSense availability. Functionality may be limited.");
      }

      updateDepthDropdown();

      // Automatically start RealSense for segmentation if available
      if (realsenseAvailable) {
        startRealSenseSeg();
        // Start depth processing with default option
        depthMode.value = "realsense_rgb_anything";
        depthTimer = setInterval(() => processDepth(depthMode.value), 500);
      } else {
        addChatMessage("Max", "RealSense not detected. Segmentation and Depth will be inactive.");
      }
      
      // Add welcome message about robot initialization
      addChatMessage("Max", "🤖 Ready! Use the robot control buttons to initialize in headless or interactive mode.");
    });

  /****************************************************
   * SEGMENTATION - RealSense Only
   ****************************************************/
  function startRealSenseSeg() {
    segVideo.style.display = "none";
    segImg.style.display = "block";
    realsenseSegTimer = setInterval(fetchRealsenseSeg, 250);
    console.log("Starting RealSense for segmentation.");
  }

  async function fetchRealsenseSeg() {
    try {
      const resp = await fetch("/process_realsense_seg", { method: "POST" });
      if (!resp.ok) {
        const errorInfo = await getDetailedErrorInfo(resp, "RealSense Segmentation");
        console.error("RealSense fetch error details:", errorInfo);
        throw new Error(`Failed to fetch RealSense frame: ${resp.status} ${resp.statusText}`);
      }
      const d = await resp.json();
      if (d.frame) segImg.src = "data:image/jpeg;base64," + d.frame;
    } catch (e) {
      console.error("RealSense fetch error:", e);
      logDetailedError(e, "RealSense Segmentation");
    }
  }

  // Freeze the Seg window — no more frames will arrive until we unfreeze
  function freezeSegWindow(base64Frame) {
      segFrozen = true;
      isSegmenting = false; // Ensure it's not marked as segmenting to allow future clicks
      if (realsenseSegTimer) {
          clearInterval(realsenseSegTimer);
          realsenseSegTimer = null;
          console.log("Cleared RealSense timer to prevent frame updates. Timer ID: null");
      }

      // Swap to frozen JPEG
      segImg.src = "data:image/jpeg;base64," + base64Frame;
      segVideo.style.display = "none";
      segImg.style.display = "block";
      console.log("Segmentation window frozen with captured frame. State: segFrozen=" + segFrozen + ", isSegmenting=" + isSegmenting + ", Timer: " + (realsenseSegTimer ? "Active" : "Cleared"));
  }

  // Unfreeze & resume RealSense feed
  function unfreezeSegWindow() {
      segFrozen = false;
      fetch("/reset_seg", { method: "POST" }).catch(e => {
        console.error("Reset seg error:", e);
        logDetailedError(e, "Reset Segmentation");
      });

      if (realsenseAvailable && !realsenseSegTimer) {
          realsenseSegTimer = setInterval(fetchRealsenseSeg, 250);
          console.log("Started RealSense timer for frame updates. Timer ID: " + realsenseSegTimer);
      }
      console.log("Segmentation window unfrozen. State: segFrozen=" + segFrozen + ", isSegmenting=" + isSegmenting + ", Timer: " + (realsenseSegTimer ? "Active" : "Not Started"));
  }

segContainer.addEventListener("click", async ev => {
    if (!realsenseAvailable) return;

    // FIRST CLICK: freeze and segment
    if (!segFrozen) {
        try {
            isSegmenting = true;
            console.log("First click: Capturing frame for segmentation. State before: segFrozen=" + segFrozen + ", isSegmenting=" + isSegmenting);
            const frameB64 = await captureSegFrame();
            freezeSegWindow(frameB64);

            // Get the image element and its bounding rectangle in the browser
            const imgElement = segImg.style.display !== "none" ? segImg : segVideo;
            const rr = imgElement.getBoundingClientRect();

            // Get the natural dimensions of the image (original size)
            const naturalWidth = imgElement.naturalWidth || imgElement.videoWidth || 640; // Fallback to expected width if unknown
            const naturalHeight = imgElement.naturalHeight || imgElement.videoHeight || 480; // Fallback to expected height if unknown

            // Compute the displayed dimensions and aspect ratio
            const displayedWidth = rr.width;
            const displayedHeight = rr.height;
            const aspectRatio = naturalWidth / naturalHeight;

            // Calculate the actual content area within the container (due to object-fit: contain)
            let contentWidth, contentHeight, offsetX, offsetY;
            if (displayedWidth / displayedHeight > aspectRatio) {
                // Image is constrained by height, black bars on sides
                contentHeight = displayedHeight;
                contentWidth = displayedHeight * aspectRatio;
                offsetX = (displayedWidth - contentWidth) / 2;
                offsetY = 0;
            } else {
                // Image is constrained by width, black bars on top/bottom
                contentWidth = displayedWidth;
                contentHeight = displayedWidth / aspectRatio;
                offsetY = (displayedHeight - contentHeight) / 2;
                offsetX = 0;
            }

            // Compute click position relative to the content area
            const clickX = ev.clientX - rr.left - offsetX;
            const clickY = ev.clientY - rr.top - offsetY;

            // Normalize click coordinates to the natural image dimensions
            const nx = (clickX / contentWidth) * naturalWidth;
            const ny = (clickY / contentHeight) * naturalHeight;

            // Ensure coordinates are within bounds
            const clampedNx = Math.max(0, Math.min(naturalWidth, nx)) / naturalWidth;
            const clampedNy = Math.max(0, Math.min(naturalHeight, ny)) / naturalHeight;

            console.log(`Click at normalized coords: (${clampedNx.toFixed(3)}, ${clampedNy.toFixed(3)}) based on natural size ${naturalWidth}x${naturalHeight}`);

            const resp = await fetch("/process_seg", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ frame: frameB64, clicked_x: clampedNx, clicked_y: clampedNy })
            });
            if (resp.ok) {
                const dd = await resp.json();
                if (dd.object_info) {
                    addChatMessage(
                        "Max",
                        `Center: ${dd.object_info.center_xyz_mm.map(v => Math.round(v)).join(', ')} mm; ` +
                        `distance ${dd.object_info.distance_m.toFixed(3)} m; ` +
                        `Size ${Math.round(dd.object_info.length_mm)}×${Math.round(dd.object_info.width_mm)} mm; ` +
                        `Orientation ${Math.round(dd.object_info.orientation_deg)}°`
                    );
                }
                // Update overlay on frozen image - this now includes the verified circle
                segImg.src = "data:image/jpeg;base64," + dd.frame;
                console.log("Updated image with segmentation results and verified center point.");
            
            } else {
                const errorInfo = await getDetailedErrorInfo(resp, "Process Segmentation");
                console.error("Segmentation processing error:", errorInfo);
                addChatMessage("Max", `Segmentation error: ${formatErrorForUser(errorInfo)}`);
            }
        } catch (e) {
            console.error("Seg error:", e);
            logDetailedError(e, "Segmentation Click");
            addChatMessage("Max", `Segmentation error: ${e.message}`);
        } finally {
            isSegmenting = false;
            console.log("Segmentation complete. Final state: segFrozen=" + segFrozen + ", isSegmenting=" + isSegmenting);
        }
    }
    // SECOND CLICK: unfreeze
    else {
        unfreezeSegWindow();
    }
});

  /****************************************************
   * DEPTH
   ****************************************************/
  function updateDepthDropdown() {
    if (realsenseAvailable) {
      depthMode.innerHTML = `
        <option value="realsense_rgb_anything">RealSense RGB + Depth Anything</option>
        <option value="realsense_depth">RealSense Depth</option>
      `;
    } else {
      depthMode.innerHTML = `
        <option value="unavailable">Unavailable</option>
      `;
      depthMode.disabled = true;
      addChatMessage("Max", "RealSense not available. Depth options are disabled.");
    }
  }

  depthMode.addEventListener("change", () => {
    clearInterval(depthTimer);
    depthImg.src = "https://via.placeholder.com/320x180?text=Depth";
    const v = depthMode.value;
    if (realsenseAvailable && v !== "unavailable") {
      depthTimer = setInterval(() => processDepth(v), 500);
    }
  });

  async function processDepth(mode) {
    try {
      const r = await fetch("/process_depth", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ camera_mode: mode, local_idx: 0, frame: "" })
      });
      
      if (!r.ok) {
        const errorInfo = await getDetailedErrorInfo(r, "Depth Processing");
        console.error("Depth processing error:", errorInfo);
        return;
      }
      
      const d = await r.json();
      if (d.frame) depthImg.src = "data:image/jpeg;base64," + d.frame;
    } catch (e) {
      console.error("Depth processing error:", e);
      logDetailedError(e, "Depth Processing");
    }
  }

  /****************************************************
   * FRAME CAPTURE UTILS
   ****************************************************/
  function captureSegFrame() {
    return new Promise((res, rej) => {
      if (realsenseAvailable) {
        const p = segImg.src.split(",");
        p[1] ? res(p[1]) : rej("No RealSense frame");
      } else {
        rej("RealSense not available");
      }
    });
  }

  /****************************************************
   * CHAT
   ****************************************************/
  function addChatMessage(sender, msg) {
    if (chatMessages.children.length > 2000) chatMessages.removeChild(chatMessages.firstChild);
    const dv = document.createElement("div");
    dv.setAttribute("data-sender", sender); // Add data attribute for styling
    dv.innerHTML = `<strong>${sender}:</strong> ${msg}`;
    chatMessages.appendChild(dv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
  }

  async function sendChatStream(customText) {
      const userText = (customText || chatInput.value).trim();
      if (!userText) return;

      // Store current user message for results
      window.current_user_message = userText;
      // Don't set a fake path here - let the server provide the real one

      chatInput.value = "";
      addChatMessage("You", userText);

      // Clear reasoning window
      llmConsole.innerHTML = "";

      // Clear action plan visualization
      clearActionPlan();

      // Unfreeze segmentation window and reset state to ensure fresh frames
      unfreezeSegWindow();

      try {
          console.log("🔍 Attempting streaming request...");
          const success = await tryStreamingChat(userText);

          if (!success) {
              console.log("🔄 Streaming failed, trying non-streaming fallback...");
              await tryFallbackChat(userText);
          }
      } catch (error) {
          console.error("❌ Chat error:", error);
          logDetailedError(error, "Chat Stream");
          addChatMessage("Max", `Error: ${error.message}. Please try again.`);
      }
  }

  async function tryStreamingChat(userText) {
      try {
          console.log("📤 Attempting fetch to /chat-stream");
          const resp = await fetch("/chat-stream", {
              method: "POST",
              headers: { 
                  "Content-Type": "application/json",
                  "Accept": "text/event-stream",
                  "Cache-Control": "no-cache"
              },
              body: JSON.stringify({ text: userText })
          });

          if (!resp.ok) {
              console.log(`❌ Streaming response not ok: ${resp.status}`);
              const errorInfo = await getDetailedErrorInfo(resp, "Chat Stream");
              console.error("Streaming error details:", errorInfo);
              addChatMessage("Max", `Chat streaming failed: ${formatErrorForUser(errorInfo)}`);
              return false;
          }

          const reader = resp.body.getReader();
          const decoder = new TextDecoder();
          let reasoning = "";
          let answer = "";
          let actionBuffer = "";
          let allContent = "";
          let lastUpdateTime = Date.now();
          const TIMEOUT_MS = 30000; // 30 second timeout

          // Add timeout monitoring
          const timeoutCheck = setInterval(() => {
              if (Date.now() - lastUpdateTime > TIMEOUT_MS) {
                  console.log("⏰ Stream timeout detected, falling back to non-streaming");
                  clearInterval(timeoutCheck);
                  reader.cancel();
                  return false;
              }
          }, 5000);

          try {
              while (true) {
                  const { done, value } = await reader.read();
                  if (done) {
                      console.log("✅ Stream completed normally");
                      break;
                  }

                  lastUpdateTime = Date.now(); // Update last activity time
                  const chunk = decoder.decode(value, { stream: true });
                  const lines = chunk.split('\n');

                  for (const line of lines) {
                      if (!line.trim()) continue;

                      if (line.startsWith("data: ")) {
                          let content = line.slice(6).trim();

                          if (content === "[DONE]") {
                              console.log("✅ Received [DONE] signal");
                              clearInterval(timeoutCheck);
                              break;
                          }
                          
                          // Handle thinking and response content
                          if (content.startsWith("thinking:")) {
                              const thinkingToken = content.slice(9);
                              reasoning = appendWithProperSpacing(reasoning, thinkingToken);
                              llmConsole.textContent = reasoning;
                              llmConsole.scrollTop = llmConsole.scrollHeight;
                          } else if (content.startsWith("response:")) {
                              const responseToken = content.slice(9);
                              answer = appendWithProperSpacing(answer, responseToken);
                              actionBuffer += responseToken;
                              allContent = appendWithProperSpacing(allContent, responseToken);
                              
                              // Update reasoning display with all content
                              const displayContent = reasoning + (reasoning && allContent ? "\n\n--- RESPONSE ---\n" : "") + allContent;
                              llmConsole.textContent = displayContent;
                              llmConsole.scrollTop = llmConsole.scrollHeight;
                          } else {
                              answer = appendWithProperSpacing(answer, content);
                              actionBuffer += content;
                              allContent = appendWithProperSpacing(allContent, content);
                              
                              // Update reasoning display with all content
                              const displayContent = reasoning + (reasoning && allContent ? "\n\n--- RESPONSE ---\n" : "") + allContent;
                              llmConsole.textContent = displayContent;
                              llmConsole.scrollTop = llmConsole.scrollHeight;
                          }

                          // Check for [ACTION] in the accumulated buffer
                          if (actionBuffer.includes("[ACTION]")) {
                              console.log("✅ [ACTION] block detected in streaming!");
                              clearInterval(timeoutCheck);
                              const actionResult = extractAndProcessAction(actionBuffer);
                              if (actionResult.processed) {
                                  actionBuffer = actionResult.remainingBuffer;
                                  return true;
                              }
                          }
                      }
                  }
              }
          } catch (streamError) {
              console.error("❌ Stream reading error:", streamError);
              clearInterval(timeoutCheck);
              return false;
          }

          clearInterval(timeoutCheck);

          // After streaming, if no action was processed, show the response
          if (answer.trim() && !answer.includes("[ACTION]")) {
              console.log("✅ No action detected, showing regular chat response.");
              addChatMessage("Max", answer.trim());
              return true;
          }

          // Final attempt to process action if present
          if (actionBuffer.includes("[ACTION]")) {
              console.log("✅ [ACTION] detected at stream end, final processing attempt.");
              const actionResult = extractAndProcessAction(actionBuffer);
              if (actionResult.processed) {
                  return true;
              }
          }

          console.log("❌ No valid response or action processed.");
          return false;
      } catch (error) {
          console.error("❌ Streaming error:", error);
          logDetailedError(error, "Chat Stream Request");
          addChatMessage("Max", `Streaming error: ${error.message}`);
          return false;
      }
  }

  // Helper function to properly append text with correct spacing
  function appendWithProperSpacing(existingText, newToken) {
      if (!existingText || !newToken) {
          return (existingText || "") + (newToken || "");
      }

      const lastChar = existingText.slice(-1);
      const firstChar = newToken[0];

      // Don't add space if:
      // 1. Last char is already whitespace
      // 2. First char is whitespace or punctuation that should connect
      // 3. We're dealing with punctuation that should connect to previous word
      if (/\s/.test(lastChar) || 
          /[\s.,!?;:)]/.test(firstChar) || 
          /[(["]/.test(lastChar)) {
          return existingText + newToken;
      }

      // Don't add space if last char is punctuation that typically doesn't need space after
      // when followed by certain characters
      if (/[.,!?;:]/.test(lastChar) && /[)\]"']/.test(firstChar)) {
          return existingText + newToken;
      }

      // Add space if both are alphanumeric or if transitioning from punctuation to alphanumeric
      if ((/[a-zA-Z0-9]/.test(lastChar) && /[a-zA-Z0-9]/.test(firstChar)) ||
          (/[.,!?;:]/.test(lastChar) && /[a-zA-Z0-9]/.test(firstChar))) {
          return existingText + " " + newToken;
      }

      // Default: no space
      return existingText + newToken;
  }

  // Keep the old function for backward compatibility but make it use the new one
  function needsSpace(existingText, newToken) {
      if (!existingText || !newToken) return false;
      const result = appendWithProperSpacing(existingText, newToken);
      return result === existingText + " " + newToken;
  }

  async function testServerConnection() {
      try {
          const resp = await fetch("/camera_info", {
              method: "GET",
              signal: AbortSignal.timeout(5000) // 5s timeout
          });
          if (resp.ok) {
              console.log("✅ Server connection OK");
              return true;
          } else {
              throw new Error(`Server returned ${resp.status}`);
          }
      } catch (e) {
          console.error("❌ Server connection failed:", e);
          addChatMessage("Max", "⚠️ Server connection issues detected. Some features may not work.");
          return false;
      }
  }

  // Update your existing DOMContentLoaded event:
  window.addEventListener("DOMContentLoaded", async () => {
      // Test connection first
      await testServerConnection();
      
      // Start robot monitoring
      startRobotStatusMonitoring();
      
      // Rest of your existing initialization code...
  });

function extractAndProcessAction(buffer) {
    const actionIndex = buffer.indexOf("[ACTION]");
    if (actionIndex === -1) {
        return { processed: false, remainingBuffer: buffer };
    }

    // Extract content after [ACTION]
    const actionContent = buffer.slice(actionIndex).trim();
    console.log("🔍 Extracted [ACTION] content:", actionContent);

    // SIMPLE CHECK: Just look for "RoboPoint Request:" - don't worry about complete parsing here
    if (!actionContent.includes("RoboPoint Request:")) {
        console.log("🔍 Incomplete [ACTION] block, waiting for more content.");
        return { processed: false, remainingBuffer: buffer };
    }

    console.log("✅ Complete [ACTION] block found, processing...");
    addChatMessage("Max", "🤖 Processing action request... Searching for objects.");
    
    // Call the bulletproof parser directly
    executeMultiStepActions(actionContent);

    const remainingBuffer = buffer.slice(actionIndex + actionContent.length).trim();
    return { processed: true, remainingBuffer };
}

  async function tryFallbackChat(userText) {
      for (let attempt = 1; attempt <= 3; attempt++) {
          try {
              addChatMessage("Max", `Processing your request... (attempt ${attempt}/3)`);
              console.log(`📤 Fallback attempt ${attempt} to /chat`);
              
              const resp = await fetch("/chat", {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ text: userText }),
                  signal: AbortSignal.timeout(30000) // 30s timeout
              });

              if (!resp.ok) {
                  const errorText = await resp.text();
                  throw new Error(`HTTP ${resp.status}: ${errorText.substring(0, 100)}`);
              }

              const data = await resp.json();
              console.log("🔍 Fallback response:", data);

              const response = data.reply || data.answer || "";
              if (response) {
                  if (response.includes("[ACTION]")) {
                      console.log("✅ [ACTION] detected in fallback response, processing...");
                      addChatMessage("Max", "🤖 Processing action request... Searching for objects.");
                      await executeMultiStepActions(response);
                  } else {
                      console.log("✅ No action in fallback, showing regular response.");
                      addChatMessage("Max", response);
                  }
                  return; // Success, exit
              } else {
                  throw new Error("Empty response from server");
              }
              
          } catch (error) {
              console.error(`❌ Fallback attempt ${attempt} failed:`, error);
              
              if (attempt === 3) {
                  // Final attempt failed
                  addChatMessage("Max", `❌ All connection attempts failed. Issues detected:
  • Network: ${error.message}
  • Try: Refresh page or check server status`);
                  return;
              }
              
              // Wait before retry (progressive backoff)
              await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
              addChatMessage("Max", `🔄 Retrying connection... (${attempt}/3)`);
          }
      }
  }

function validateAndFixActions(objects, actions) {
    console.log("🔧 Validating actions - Objects:", objects, "Actions:", actions);
    
    // Common fixes for malformed actions
    const fixedActions = actions.map(action => {
        action = action.toLowerCase().trim();
        
        // Fix common malformations
        if (action.includes("pick") && action.includes("place")) {
            return ["pick", "place"]; // Split combined action
        } else if (action.includes("pick")) {
            return "pick";
        } else if (action.includes("place") || action.includes("put")) {
            return "place";
        }
        return action;
    }).flat(); // Flatten in case we split any actions
    
    // If we have 2 objects but 1 action, default to pick + place
    if (objects.length === 2 && fixedActions.length === 1) {
        return ["pick", "place"];
    }
    
    return fixedActions;
}

async function executeMultiStepActions(actionBlock) {
    console.log("🔍 DEBUG: Raw action block:", actionBlock);

    window.robopoint_results = [];
    window.current_results = {
        user_message: window.current_user_message || "Unknown command",
        imagePath: "Unknown path",
        objects: []
    };

    try {
        // BULLETPROOF EXTRACTION
        let content = actionBlock.replace(/\[ACTION\]/i, '').trim();
        console.log("🔍 Raw content:", content);

        // ENHANCED FIX: Handle various malformed patterns
        content = content.replace(/([a-zA-Z\s])Action\s*Request:/g, '$1\nAction Request:');
        content = content.replace(/([a-zA-Z\s])Action:/g, '$1\nAction Request:');
        content = content.replace(/Request:\s*([^;]+);([^A])/, 'Request: $1; $2'); // Fix missing spaces
        console.log("🔍 Fixed content:", content);

        // Extract RoboPoint content - everything before first "Action Request"
        const roboPointRegex = /RoboPoint\s*Request:\s*([^]*?)(?=\n\s*Action\s*Request:|$)/i;
        const roboPointMatch = content.match(roboPointRegex);
        
        if (!roboPointMatch) {
            addChatMessage("Max", "Error: Could not find RoboPoint Request");
            return;
        }

        let roboPointContent = roboPointMatch[1].trim();
        
        // ENHANCED CLEANING: Remove trailing "Action" artifacts
        roboPointContent = roboPointContent.replace(/\s*Action\s*$/i, '').trim();
        roboPointContent = roboPointContent.replace(/\s*Request\s*$/i, '').trim();
        console.log("🔍 Cleaned RoboPoint content:", roboPointContent);

        // SMART OBJECT EXTRACTION - preserve complete descriptions
        let objects = [];
        if (roboPointContent.includes(';')) {
            // Multiple objects separated by semicolons - preserve each complete description
            objects = roboPointContent
                .split(';')
                .map(s => s.trim())
                .filter(s => s && s.length > 0);
        } else {
            // Single object - keep it whole
            objects = [roboPointContent];
        }

        // LOCATION VALIDATION - check if locations were incorrectly split
        const fixedObjects = [];
        for (let i = 0; i < objects.length; i++) {
            const obj = objects[i];
            const nextObj = objects[i + 1];
            
            // Check if next "object" is actually a location descriptor
            if (nextObj && isLocationDescriptor(nextObj)) {
                // Combine object with its location
                fixedObjects.push(`${obj} ${nextObj}`);
                i++; // Skip the next object since we combined it
                console.log(`🔧 Combined "${obj}" with location "${nextObj}"`);
            } else {
                fixedObjects.push(obj);
            }
        }
        
        objects = fixedObjects;

        // Extract actions (look for Action Request patterns)
        const actionRegex = /Action\s*Request:\s*(\w+)/gi;
        const actionMatches = [...content.matchAll(actionRegex)];
        
        let actions = actionMatches
            .map(match => match[1] ? match[1].trim() : "")
            .filter(s => s && s.length > 0);

        console.log("🔍 Raw objects:", objects);
        console.log("🔍 Raw actions:", actions);

        // SMART DEFAULTS: Auto-generate actions if missing
        if (actions.length === 0) {
            if (objects.length >= 2) {
                actions = ['Pick', 'Place'];
                console.log("🔧 Auto-generated Pick/Place for 2+ objects");
            } else if (objects.length === 1) {
                actions = ['Pick'];
                console.log("🔧 Auto-generated Pick for 1 object");
            }
        }

        // INTELLIGENT MATCHING: Handle mismatched objects/actions
        if (objects.length !== actions.length) {
            if (objects.length === 2 && actions.length === 1) {
                actions = ['Pick', 'Place'];
                console.log("🔧 Expanded to Pick/Place for 2 objects");
            } else if (objects.length === 1 && actions.length === 0) {
                actions = ['Pick'];
                console.log("🔧 Added Pick action for single object");  
            } else {
                // Match to minimum length
                const minLength = Math.min(objects.length, actions.length);
                if (minLength > 0) {
                    objects = objects.slice(0, minLength);
                    actions = actions.slice(0, minLength);
                    console.log("🔧 Matched objects/actions to minimum length");
                }
            }
        }

        console.log("🔍 FINAL - Objects:", objects);
        console.log("🔍 FINAL - Actions:", actions);

        if (objects.length === 0) {
            addChatMessage("Max", "Error: No valid objects found after parsing");
            return;
        }

        // VALIDATION: Check for complete object descriptions
        for (const obj of objects) {
            if (obj.length < 2) {
                console.warn("⚠️ Suspicious short object:", obj);
            }
        }

        // SUCCESS - show what we parsed
        addChatMessage("Max", `✅ Parsed: ${objects.map((obj, i) => `${actions[i]} "${obj}"`).join(', ')}`);

        // Continue with execution...
        unfreezeSegWindow();
        await new Promise(resolve => setTimeout(resolve, 300));

        let frameB64 = "";
        try {
            frameB64 = await captureSegFrame();
            freezeSegWindow(frameB64);
        } catch (e) {
            console.warn("No seg frame:", e);
            addChatMessage("Max", "Warning: Could not capture frame. Continuing...");
        }

        // Execute each command
        for (let i = 0; i < objects.length; i++) {
            const object = objects[i];
            const action = actions[i];

            addChatMessage("Max", `🔄 Step ${i+1}: ${action} "${object}"`);

            try {
                const result = await executeRoboPointCommand(object, action, frameB64);

                if (i === 0 && result.image_path) {
                    window.current_results.imagePath = result.image_path;
                }

                if (result.seg_frame) {
                    segImg.src = "data:image/jpeg;base64," + result.seg_frame;
                }

                if (result.object_info && result.object_info.center_xyz_mm) {
                    const info = result.object_info;
                    window.current_results.objects.push({
                        action: action.toLowerCase(),
                        location: result.placement || "unknown",
                        object: object,
                        object_center_location: {
                            x: Math.round(info.center_xyz_mm[0]),
                            y: Math.round(info.center_xyz_mm[1]),
                            z: Math.round(info.center_xyz_mm[2])
                        },
                        object_size: {
                            width: Math.round(info.width_mm),
                            length: Math.round(info.length_mm)
                        },
                        object_orientation: Math.round(info.orientation_deg)
                    });
                    
                    addChatMessage("Max", `✅ Found "${object}" at ${info.center_xyz_mm.map(v=>Math.round(v)).join(', ')} mm`);
                } else {
                    window.current_results.objects.push({
                        action: action.toLowerCase(),
                        location: result.placement || "unknown",
                        object: object,
                        object_center_location: { x: 0, y: 0, z: 0 },
                        object_size: { width: 0, length: 0 },
                        object_orientation: 0
                    });
                    addChatMessage("Max", `✅ Found "${object}"`);
                }

          if (i < objects.length - 1) {
                      addChatMessage("Max", `⏳ Waiting for RoboPoint service...`);
                      await new Promise(resolve => setTimeout(resolve, 3000)); // Increased from 800ms to 3s
                  }
              } catch (error) {
                  console.error(`❌ Step ${i+1} failed:`, error);
                  addChatMessage("Max", `❌ Step ${i+1} failed: ${error.message}`);
                  break;
              }
          }

        console.log("🤖 FINAL RESULTS:", JSON.stringify(window.current_results, null, 2));
        addChatMessage("Max", `🎉 Completed ${objects.length} step(s)!`);
        
        addChatMessage("Max", "🚀 Sending to Max Planner...");
        try {
            await callExecPlannerStream(window.current_results);
        } catch (error) {
            console.error("❌ Planner failed:", error);
            addChatMessage("Max", `❌ Planner failed: ${error.message}`);
        }
        
    } catch (error) {
        console.error("❌ Action parsing error:", error);
        addChatMessage("Max", `Parsing error: ${error.message}`);
        unfreezeSegWindow();
    }
}

// Helper function to identify location descriptors
function isLocationDescriptor(text) {
    const locationWords = [
        'middle', 'center', 'centre',
        'top', 'bottom', 'left', 'right',
        'upper', 'lower', 'front', 'back',
        'near', 'far', 'close', 'distant',
        'corner', 'edge', 'side'
    ];
    
    const words = text.toLowerCase().split(/\s+/);
    return words.some(word => locationWords.includes(word)) && words.length <= 3;
}

async function executeRoboPointCommand(objectDescription, action, frameB64, retries = 3) {
    const singleActionBlock = `[ACTION]\nRoboPoint Request: ${objectDescription}\nAction Request: ${action}`;
    
    for (let attempt = 1; attempt <= retries; attempt++) {
        console.log(`📤 Attempt ${attempt}: Sending to RoboPoint:`, singleActionBlock);
        
        try {
            // Add exponential backoff for retries
            if (attempt > 1) {
                const delay = Math.min(2000 * Math.pow(2, attempt - 2), 10000); // 2s, 4s, 8s max
                addChatMessage("Max", `⏳ Retrying in ${delay/1000}s... (attempt ${attempt}/${retries})`);
                await new Promise(resolve => setTimeout(resolve, delay));
            }

            // Test RoboPoint service availability first
            if (attempt > 1) {
                addChatMessage("Max", `🔍 Testing RoboPoint service connection...`);
                const healthCheck = await testRoboPointHealth();
                if (!healthCheck) {
                    throw new Error("RoboPoint service is not responding to health check");
                }
                addChatMessage("Max", `✅ RoboPoint service is responsive`);
            }

            const resp = await fetch("/exec_action", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    action_block: singleActionBlock,
                    seg_frame: frameB64
                }),
                signal: AbortSignal.timeout(120000) // 2 minute timeout
            });

            if (!resp.ok) {
                const errorInfo = await getDetailedErrorInfo(resp, "Execute RoboPoint Command");
                console.error(`Attempt ${attempt} failed:`, errorInfo);
                
                // Check if it's a server error vs network error
                if (resp.status >= 500) {
                    addChatMessage("Max", `⚠️ RoboPoint server error (${resp.status}). Retrying...`);
                } else if (resp.status === 0) {
                    addChatMessage("Max", `⚠️ Network connection lost. Retrying...`);
                } else {
                    throw new Error(formatErrorForUser(errorInfo));
                }
                
                if (attempt === retries) {
                    throw new Error(formatErrorForUser(errorInfo));
                }
                continue;
            }

            const result = await resp.json();
            console.log("📥 RoboPoint result:", result);
            
            if (result.error) {
                throw new Error(`RoboPoint server error: ${result.error}`);
            }
            
            addChatMessage("Max", `✅ RoboPoint responded successfully for "${objectDescription}"`);
            return result;
            
        } catch (error) {
            console.error(`❌ Attempt ${attempt} error:`, error);
            
            if (error.name === 'TimeoutError') {
                addChatMessage("Max", `⏰ Request timeout on attempt ${attempt}`);
            } else if (error.message.includes('NetworkError') || error.message.includes('fetch')) {
                addChatMessage("Max", `🌐 Network error on attempt ${attempt}: ${error.message}`);
            } else {
                addChatMessage("Max", `❌ Error on attempt ${attempt}: ${error.message}`);
            }
            
            if (attempt === retries) {
                addChatMessage("Max", `❌ All ${retries} attempts failed for "${objectDescription}"`);
                throw error;
            }
        }
    }
}

async function resetRoboPointService() {
    try {
        addChatMessage("Max", "🔄 Attempting to reset RoboPoint service state...");
        
        // Call reset endpoint if available
        const resp = await fetch("/reset_seg", {
            method: "POST",
            signal: AbortSignal.timeout(10000)
        });
        
        if (resp.ok) {
            addChatMessage("Max", "✅ RoboPoint service state reset");
            // Give service time to fully reset
            await new Promise(resolve => setTimeout(resolve, 2000));
            return true;
        }
        return false;
    } catch (e) {
        console.error("Service reset failed:", e);
        return false;
    }
}

  // Function to call exec_planner endpoint
  async function callExecPlanner(currentResults, headless = true) {
      try {
          console.log("📤 Calling exec_planner with results:", currentResults);
          
          const resp = await fetch("/exec_planner", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                  current_results: currentResults,
                  headless: headless
              }),
              timeout: 120000 // 2 minute timeout for planner execution
          });

          if (!resp.ok) {
              const errorInfo = await getDetailedErrorInfo(resp, "Execute Planner");
              console.error("Exec planner error details:", errorInfo);
              throw new Error(formatErrorForUser(errorInfo));
          }

          const result = await resp.json();
          console.log("📥 Exec planner result:", result);
          
          return result;
      } catch (error) {
          console.error("❌ callExecPlanner error:", error);
          throw error;
      }
  }

  // Function to call exec_planner_stream endpoint and display output in LLM Reasoning panel
  async function callExecPlannerStream(currentResults, headless = true) {
      try {
          console.log("📤 Calling exec_planner_stream with results:", currentResults);
          
          // Clear the LLM Reasoning panel
          llmConsole.innerHTML = "";
          
          const resp = await fetch("/exec_planner_stream", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                  current_results: currentResults,
                  headless: headless
              })
          });

          if (!resp.ok) {
              const errorInfo = await getDetailedErrorInfo(resp, "Execute Planner Stream");
              console.error("Exec planner stream error details:", errorInfo);
              throw new Error(formatErrorForUser(errorInfo));
          }

          const reader = resp.body.getReader();
          const decoder = new TextDecoder();
          let plannerOutput = "";
          let plannerCompleted = false;
          let plannerSuccess = false;

          while (true) {
              const { done, value } = await reader.read();
              if (done) break;

              const chunk = decoder.decode(value, { stream: true });
              const lines = chunk.split('\n');

              for (const line of lines) {
                  if (!line.trim()) continue;

                  if (line.startsWith("data: ")) {
                      let content = line.slice(6);

                      if (content.trim() === "[DONE]") {
                          plannerCompleted = true;
                          break;
                      }

                      if (content) {
                          // Comprehensive formatting to ensure proper line breaks and structure
                          let processedContent = content;
                          
                          // Define patterns that need line breaks BEFORE them
                          const needsNewlineBefore = [
                              // Major section headers
                              /🚀{15,}/,  // Rocket emoji lines
                              /🎉{15,}/,  // Party emoji lines  
                              /🤖{15,}/,  // Robot emoji lines
                              /🔧{15,}/,  // Tool emoji lines
                              /={15,}/,   // Equal sign dividers
                              /-{15,}/,   // Dash dividers
                              
                              // Section titles
                              /RUNNING COMPLETE.*PIPELINE/,
                              /4-STEP PIPELINE COMPLETED/,
                              /EXECUTING GENERATED PLAN/,
                              /COORDINATE TRANSFORMATION/,
                              
                              // Step headers
                              /STEP \d+:/,
                              /🔍 STEP/,
                              /✅ STEP/,
                              /🧠 STEP/,
                              /🚀 STEP/,
                              
                              // Info and status messages
                              /\[INFO\]/,
                              /\[WARNING\]/,
                              /\[ERROR\]/,
                              /\[VALID\]/,
                              /\[STEP \d+ (RESULT|SUCCESS|OUTPUT)\]/,
                              /\[CONSISTENCY CHECK\]/,
                              /\[TRANSFORM\]/,
                              
                              // Streaming markers
                              /\[STREAMING (VLM|LLM) RESPONSE\]/,
                              /\[(VLM|LLM) RESPONSE COMPLETE\]/,
                              
                              // Markdown headers
                              /^#{1,6} /,
                              /^### /,
                              /^- \*\*/,  // Bold list items
                              
                              // Special content
                              /REFINED_OBJECTS:/,
                              /REFINED_RELATIONSHIPS:/,
                              /REASONING:/
                          ];
                          
                          // Check if content needs a line break before it
                          const needsBreakBefore = needsNewlineBefore.some(pattern => pattern.test(content));
                          
                          // Add line break before if needed (but not if already at start of line)
                          if (needsBreakBefore && plannerOutput && !plannerOutput.endsWith('\n')) {
                              processedContent = '\n' + processedContent;
                          }
                          
                          // Define patterns that need line breaks AFTER them
                          const needsNewlineAfter = [
                              /🚀{15,}/,
                              /🎉{15,}/,
                              /🤖{15,}/,
                              /🔧{15,}/,
                              /={15,}/,
                              /-{15,}/,
                              /\[STREAMING (VLM|LLM) RESPONSE\]/,
                              /\[(VLM|LLM) RESPONSE COMPLETE\]/,
                              /RUNNING COMPLETE.*PIPELINE/,
                              /4-STEP PIPELINE COMPLETED/,
                              /EXECUTING GENERATED PLAN/,
                              /COORDINATE TRANSFORMATION/
                          ];
                          
                          // Add line break after if needed
                          if (needsNewlineAfter.some(pattern => pattern.test(content)) && !processedContent.endsWith('\n')) {
                              processedContent += '\n';
                          }
                          
                          // Add the processed content
                          plannerOutput += processedContent;
                          
                          // Use textContent to preserve whitespace with pre-wrap CSS
                          llmConsole.textContent = plannerOutput;
                          llmConsole.scrollTop = llmConsole.scrollHeight;
                          
                          // Check for success indicators
                          if (content.includes("✅ Robot execution completed successfully")) {
                              plannerSuccess = true;
                              addChatMessage("Max", "🤖 Robot execution completed successfully!");
                          } else if (content.includes("❌ Robot execution failed")) {
                              addChatMessage("Max", "❌ Robot execution failed");
                          } else if (content.includes("Generated action plan:") || content.includes("[STEP 4 RESULT] Final Action Plan:") || content.includes("[STEP 4 RESULT] Final Transformed Plan:")) {
                              // Display the action plan sequentially (one by one) immediately when detected
                              console.log("🎯 Action plan detected, processing:", content);
                              extractActionPlanFromOutput(content);
                          } else if (content.includes("4-STEP PIPELINE COMPLETED")) {
                              addChatMessage("Max", "✅ Action plan generation completed! Plan visualization ready.");
                          } else if (content.includes("EXECUTING GENERATED PLAN ON ROBOT")) {
                              addChatMessage("Max", "⏳ Action plan ready! Preparing for execution...");
                              // Reset all actions to pending status immediately for clean visualization
                              if (window.currentActionPlan && window.currentActionPlan.length > 0) {
                                  for (let i = 0; i < window.currentActionPlan.length; i++) {
                                      updateActionStatus(i, 'pending');
                                  }
                              }
                          } else if (content.includes("Robot will start execution in 3 seconds") || content.includes("Displaying action plan... Robot will start execution in 3 seconds")) {
                              addChatMessage("Max", "⏳ Action plan complete! Robot will start execution in 3 seconds...");
                              // Show countdown
                              let countdown = 3;
                              const countdownInterval = setInterval(() => {
                                  countdown--;
                                  if (countdown > 0) {
                                      addChatMessage("Max", `⏰ Starting in ${countdown} seconds...`);
                                  } else {
                                      clearInterval(countdownInterval);
                                  }
                              }, 1000);
                          } else if (content.includes("Starting robot execution now")) {
                              addChatMessage("Max", `🚀 Starting execution of ${window.currentActionPlan ? window.currentActionPlan.length : 'N/A'} actions`);
                          } else if (content.includes("Max planner completed with success: true")) {
                              addChatMessage("Max", "✅ Max Planner executed successfully!");
                          } else if (content.includes("Max planner completed with success: false")) {
                              addChatMessage("Max", "❌ Max Planner failed");
                          }
                          
                          // Check for action execution status updates
                          if (content.includes("Executing action") && content.includes("of")) {
                              // Pattern: "Executing action X of Y"
                              const actionMatch = content.match(/Executing action (\d+) of (\d+)/);
                              if (actionMatch) {
                                  const currentAction = parseInt(actionMatch[1]) - 1; // Convert to 0-based index
                                  const totalActions = parseInt(actionMatch[2]);
                                  
                                  // Mark previous actions as completed
                                  for (let i = 0; i < currentAction; i++) {
                                      updateActionStatus(i, 'completed');
                                  }
                                  // Mark current action
                                  updateActionStatus(currentAction, 'current');
                                  
                                  addChatMessage("Max", `🔄 Executing step ${currentAction + 1} of ${totalActions}`);
                              }
                          } else if (content.includes("Action completed successfully")) {
                              // Mark current action as completed
                              if (window.currentActionIndex >= 0) {
                                  updateActionStatus(window.currentActionIndex, 'completed');
                                  addChatMessage("Max", `✅ Step ${window.currentActionIndex + 1} completed`);
                              }
                          } else if (content.includes("Robot execution completed successfully")) {
                              // Mark all remaining actions as completed
                              if (window.currentActionPlan && window.currentActionPlan.length > 0) {
                                  for (let i = 0; i < window.currentActionPlan.length; i++) {
                                      updateActionStatus(i, 'completed');
                                  }
                              }
                          }
                      }
                  }
              }

              if (plannerCompleted) break;
          }

          console.log("📥 Exec planner stream completed");
          
      } catch (error) {
          console.error("❌ callExecPlannerStream error:", error);
          llmConsole.innerHTML += `\nERROR: ${error.message}`;
          throw error;
      }
  }

  /****************************************************
   * ACTION PLAN VISUALIZATION
   ****************************************************/
  
  // Action to icon mapping
  const actionIconMap = {
    'pick': 'PickupObject.png',
    'pickup': 'PickupObject.png',
    'pickupobject': 'PickupObject.png',
    'place': 'PutDownObject.png',
    'put': 'PutDownObject.png',
    'putdown': 'PutDownObject.png',
    'putdownobject': 'PutDownObject.png',
    'move': 'MovetoObject.png',
    'moveto': 'MovetoObject.png',
    'movetoobject': 'MovetoObject.png',
    'pickmove': 'MovetoObject.png',
    'placemove': 'MovetoObject.png',
    'home': 'Home.png',
    'open': 'OpenGripper.png',
    'close': 'CloseGripper.png',
    'opengripper': 'OpenGripper.png',
    'closegripper': 'CloseGripper.png'
  };

  // Global variables to store current action plan
  window.currentActionPlan = [];
  window.currentActionIndex = -1;
  window.pendingActionPlan = null;

  function parseActionPlan(planText) {
    console.log("🔍 Parsing action plan:", planText);
    
    // Look for action plan patterns like: (Object, (x, y, z), action) -> (Object, (x, y, z), action)
    // Also handle patterns without arrows: (Object, (x, y, z), action)
    const actionRegex = /\(([^,]+),\s*\(([^)]+)\),\s*([^)]+)\)/g;
    const actions = [];
    let match;
    
    while ((match = actionRegex.exec(planText)) !== null) {
      const object = match[1].trim();
      const coordinates = match[2].trim();
      const action = match[3].trim().toLowerCase();
      
      console.log(`🔍 Found action: object="${object}", coords="${coordinates}", action="${action}"`);
      
      // Parse coordinates
      const coordParts = coordinates.split(',').map(c => parseInt(c.trim()));
      
      actions.push({
        object: object,
        coordinates: {
          x: coordParts[0] || 0,
          y: coordParts[1] || 0,
          z: coordParts[2] || 0
        },
        action: action,
        status: 'pending' // pending, current, completed
      });
    }
    
    console.log("📋 Parsed actions:", actions);
    return actions;
  }

  function displayActionPlan(actions, immediate = false) {
    const container = document.getElementById('actionPlanContainer');
    const placeholder = document.getElementById('actionPlanPlaceholder');
    
    if (!actions || actions.length === 0) {
      placeholder.style.display = 'block';
      container.innerHTML = '<div id="actionPlanPlaceholder" style="color:#666; font-style:italic; font-size:1em;">Action plan will appear here</div>';
      return;
    }
    
    placeholder.style.display = 'none';
    container.innerHTML = '';
    
    // Create container for display
    const sequenceContainer = document.createElement('div');
    sequenceContainer.className = 'action-sequence';
    sequenceContainer.style.cssText = 'display: flex; align-items: center; justify-content: center; flex-wrap: wrap; gap: 8px;';
    container.appendChild(sequenceContainer);
    
    window.currentActionPlan = actions;
    
    if (immediate) {
      // Display all actions immediately (for plan preview)
      displayActionsImmediately(actions, sequenceContainer);
      console.log("✅ Action plan displayed immediately with", actions.length, "steps");
    } else {
      // Display actions one by one with arrows (for step-by-step animation)
      displayActionsSequentially(actions, sequenceContainer);
      console.log("✅ Action plan will display sequentially with", actions.length, "steps");
    }
  }

  function displayActionsImmediately(actions, container) {
    // Display all actions at once (for final plan preview)
    for (let currentIndex = 0; currentIndex < actions.length; currentIndex++) {
      const action = actions[currentIndex];
      
      // Add arrow before action (except for first action)
      if (currentIndex > 0) {
        const arrow = document.createElement('div');
        arrow.className = 'action-arrow';
        arrow.innerHTML = '→';
        arrow.style.cssText = `
          color: #4af;
          font-size: 1.5em;
          font-weight: bold;
          margin: 0 4px;
          text-shadow: 0 0 4px #4af;
        `;
        container.appendChild(arrow);
      }
      
      // Create action step
      const stepDiv = document.createElement('div');
      stepDiv.className = `action-step ${action.status}`;
      stepDiv.id = `action-step-${currentIndex}`;
      
      // Get the appropriate icon
      const iconFile = actionIconMap[action.action] || 'MovetoObject.png';
      
      stepDiv.innerHTML = `
        <img src="/icons/${iconFile}" alt="${action.action}" class="action-icon" title="${action.object} - ${action.action}">
        <div class="action-label">${action.action}</div>
        <div class="action-object" title="${action.object}">${action.object}</div>
        <div class="action-coordinates">(${action.coordinates.x}, ${action.coordinates.y}, ${action.coordinates.z})</div>
      `;
      
      container.appendChild(stepDiv);
    }
    
    console.log("✅ All action steps displayed immediately");
  }

  function displayActionsSequentially(actions, container) {
    let currentIndex = 0;
    
    function showNextAction() {
      if (currentIndex >= actions.length) {
        console.log("✅ All action steps displayed");
        return;
      }
      
      const action = actions[currentIndex];
      
      // Add arrow before action (except for first action)
      if (currentIndex > 0) {
        const arrow = document.createElement('div');
        arrow.className = 'action-arrow';
        arrow.innerHTML = '→';
        arrow.style.cssText = `
          color: #4af;
          font-size: 1.5em;
          font-weight: bold;
          margin: 0 4px;
          opacity: 0;
          transform: scale(0.5);
          transition: all 0.3s ease;
        `;
        container.appendChild(arrow);
        
        // Animate arrow appearance
        setTimeout(() => {
          arrow.style.opacity = '1';
          arrow.style.transform = 'scale(1)';
        }, 100);
      }
      
      // Create action step
      const stepDiv = document.createElement('div');
      stepDiv.className = `action-step ${action.status}`;
      stepDiv.id = `action-step-${currentIndex}`;
      
      // Get the appropriate icon
      const iconFile = actionIconMap[action.action] || 'MovetoObject.png';
      
      stepDiv.innerHTML = `
        <img src="/icons/${iconFile}" alt="${action.action}" class="action-icon" title="${action.object} - ${action.action}">
        <div class="action-label">${action.action}</div>
        <div class="action-object" title="${action.object}">${action.object}</div>
        <div class="action-coordinates">(${action.coordinates.x}, ${action.coordinates.y}, ${action.coordinates.z})</div>
      `;
      
      // Initially hide the step
      stepDiv.style.cssText = `
        opacity: 0;
        transform: scale(0.5) translateY(20px);
        transition: all 0.5s ease;
      `;
      
      container.appendChild(stepDiv);
      
      // Animate step appearance
      setTimeout(() => {
        stepDiv.style.opacity = '1';
        stepDiv.style.transform = 'scale(1) translateY(0)';
      }, 200);
      
      currentIndex++;
      
      // Show next action after delay
      setTimeout(showNextAction, 800);
    }
    
    // Start the sequence
    showNextAction();
  }

  function updateActionStatus(index, status) {
    if (index >= 0 && index < window.currentActionPlan.length) {
      window.currentActionPlan[index].status = status;
      const stepElement = document.getElementById(`action-step-${index}`);
      if (stepElement) {
        stepElement.className = `action-step ${status}`;
      }
      
      // Update current action index
      if (status === 'current') {
        window.currentActionIndex = index;
      } else if (status === 'completed' && window.currentActionIndex === index) {
        window.currentActionIndex = -1;
      }
    }
  }

  function clearActionPlan() {
    const container = document.getElementById('actionPlanContainer');
    
    container.innerHTML = '<div id="actionPlanPlaceholder" style="color:#666; font-style:italic; font-size:1em;">Action plan will appear here</div>';
    window.currentActionPlan = [];
    window.currentActionIndex = -1;
    
    console.log("🧹 Action plan cleared");
  }

  // Function to extract and display action plan from planner output (sequential animation)
  function extractActionPlanFromOutput(output) {
    // Look for different patterns of action plan output
    let planText = null;
    
    // Pattern 1: "Generated action plan: plan: ..."
    let planMatch = output.match(/Generated action plan:\s*plan:\s*(.+)/i);
    if (planMatch) {
      planText = planMatch[1];
    } else {
      // Pattern 2: "Generated action plan: ..."
      planMatch = output.match(/Generated action plan:\s*(.+)/i);
      if (planMatch) {
        planText = planMatch[1];
      } else {
        // Pattern 3: "[STEP 4 RESULT] Final Transformed Plan: ..."
        planMatch = output.match(/\[STEP 4 RESULT\] Final Transformed Plan:\s*(.+)/i);
        if (planMatch) {
          planText = planMatch[1];
        } else {
          // Pattern 4: "[STEP 4 RESULT] Final Action Plan: plan: ..."
          planMatch = output.match(/\[STEP 4 RESULT\] Final Action Plan:\s*plan:\s*(.+)/i);
          if (planMatch) {
            planText = planMatch[1];
          } else {
            // Pattern 5: "[STEP 4 RESULT] Final Action Plan: ..."
            planMatch = output.match(/\[STEP 4 RESULT\] Final Action Plan:\s*(.+)/i);
            if (planMatch) {
              planText = planMatch[1];
            }
          }
        }
      }
    }
    
    if (planText) {
      console.log("🎯 Found action plan in output:", planText);
      
      const actions = parseActionPlan(planText);
      if (actions.length > 0) {
        displayActionPlan(actions);
        addChatMessage("Max", `📋 Action Plan: ${actions.length} steps will display sequentially`);
        return true;
      }
    }
    return false;
  }

  // Function to extract and display COMPLETE action plan immediately (all icons at once)
  function extractAndDisplayCompleteActionPlan(output) {
    // Look for different patterns of action plan output
    let planText = null;
    
    // Pattern 1: "Generated action plan: plan: ..."
    let planMatch = output.match(/Generated action plan:\s*plan:\s*(.+)/i);
    if (planMatch) {
      planText = planMatch[1];
    } else {
      // Pattern 2: "Generated action plan: ..."
      planMatch = output.match(/Generated action plan:\s*(.+)/i);
      if (planMatch) {
        planText = planMatch[1];
      } else {
        // Pattern 3: "[STEP 4 RESULT] Final Transformed Plan: ..."
        planMatch = output.match(/\[STEP 4 RESULT\] Final Transformed Plan:\s*(.+)/i);
        if (planMatch) {
          planText = planMatch[1];
        } else {
          // Pattern 4: "[STEP 4 RESULT] Final Action Plan: plan: ..."
          planMatch = output.match(/\[STEP 4 RESULT\] Final Action Plan:\s*plan:\s*(.+)/i);
          if (planMatch) {
            planText = planMatch[1];
          } else {
            // Pattern 5: "[STEP 4 RESULT] Final Action Plan: ..."
            planMatch = output.match(/\[STEP 4 RESULT\] Final Action Plan:\s*(.+)/i);
            if (planMatch) {
              planText = planMatch[1];
            }
          }
        }
      }
    }
    
    if (planText) {
      console.log("🎯 Found action plan for immediate display:", planText);
      
      const actions = parseActionPlan(planText);
      if (actions.length > 0) {
        // Display ALL actions immediately (no sequential animation)
        displayActionPlan(actions, true);
        addChatMessage("Max", `📋 Final Action Plan: ${actions.length} steps ready for execution`);
        return true;
      }
    }
    return false;
  }

  // Test function for action plan visualization (can be called from browser console)
  window.testActionPlan = function() {
    const testPlan = "[STEP 4 RESULT] Final Transformed Plan: (Banana, (-24, -189, 585), move) -> (Banana, (-24, -189, 585), pick) -> (Table, (100, 200, 300), place)";
    console.log("🧪 Testing action plan with:", testPlan);
    
    // Clear any existing plan first
    clearActionPlan();
    
    // Simulate the planning phase
    addChatMessage("Max", "🧠 Generating action plan...");
    
    setTimeout(() => {
      // Simulate plan generation and immediately display sequentially
      addChatMessage("Max", "📋 Action plan generated");
      extractActionPlanFromOutput(testPlan); // This will trigger sequential display
      
      setTimeout(() => {
        // Simulate "4-STEP PIPELINE COMPLETED"
        addChatMessage("Max", "✅ Action plan generation completed! Plan visualization ready.");
        
        // Wait for all icons to appear sequentially, then continue
        setTimeout(() => {
          addChatMessage("Max", "⏳ Action plan ready! Preparing for execution...");
          addChatMessage("Max", "⏳ Action plan complete! Robot will start execution in 3 seconds...");
          
          // Show countdown
          let countdown = 3;
          const countdownInterval = setInterval(() => {
              countdown--;
              if (countdown > 0) {
                  addChatMessage("Max", `⏰ Starting in ${countdown} seconds...`);
              } else {
                  clearInterval(countdownInterval);
                  addChatMessage("Max", "🚀 Starting execution of 3 actions");
                  
                  // Reset all actions to pending for clean execution tracking
                  if (window.currentActionPlan && window.currentActionPlan.length > 0) {
                      for (let i = 0; i < window.currentActionPlan.length; i++) {
                          updateActionStatus(i, 'pending');
                      }
                  }
                  
                  // Start execution simulation
                  setTimeout(() => {
                    updateActionStatus(0, 'current');
                    addChatMessage("Max", "🔄 Executing step 1 of 3");
                  }, 1000);
                  
                  setTimeout(() => {
                    updateActionStatus(0, 'completed');
                    updateActionStatus(1, 'current');
                    addChatMessage("Max", "✅ Step 1 completed");
                    addChatMessage("Max", "🔄 Executing step 2 of 3");
                  }, 3000);
                  
                  setTimeout(() => {
                    updateActionStatus(1, 'completed');
                    updateActionStatus(2, 'current');
                    addChatMessage("Max", "✅ Step 2 completed");
                    addChatMessage("Max", "🔄 Executing step 3 of 3");
                  }, 5000);
                  
                  setTimeout(() => {
                    updateActionStatus(2, 'completed');
                    addChatMessage("Max", "✅ Step 3 completed");
                    addChatMessage("Max", "🎉 All steps completed successfully!");
                  }, 7000);
              }
          }, 1000);
          
        }, 3000); // Wait 3 seconds for all icons to appear sequentially (3 actions * 800ms + buffer)
        
      }, 1000);
      
    }, 1000);
  };

  /****************************************************
   * EVENT LISTENERS FOR CHAT
   ****************************************************/
  chatSendBtn.addEventListener("click", () => sendChatStream());
  chatInput.addEventListener("keyup", e => { if (e.key === "Enter") sendChatStream(); });
</script>

</body>
</html>